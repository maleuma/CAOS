; -----------------------------------------------------
;	Originalquelltext des KC-BASIC-ROM BM 600
;	- angepasst zu Erzeugung mit CAOS-Vorblock
;	- modifiziert zur Assemblierung mit SLRZ80
;		SLRZ80 BASIC/F
;		REN BASIC.COM BASIC.KCC
;	- verschiedene Kommentare ergaenzt durch
;	  Mario Leubner und Frank Ludwig
;
; 24.01.2021: LIST gepatcht, sodass bei Anzeige keine
; undefinierten Erweiterungstoken mit beruecksichtigt
; werden (bei MC in BASIC-Zeile)
;
; 29.05.2021: Notizspeicher-Erstbelegung korrigiert auf
; Adresse 0300H. Der Sprung zu BASIC-Warmstart fuehrte
; 3 Byte vor das eigentliche Ziel aus nicht erklaertem
; Grund.
;
; Mario Leubner			26.07.2013 - 16.02.2022
; -----------------------------------------------------
.xcref
.z80
title HC-BASIC ROM-Version 07.01.1987
	aseg

;************************************************ 
ROMBEG	EQU	0C000H	; INTERPRETERANFANGSADR.
RAMBEG	EQU	300H	; RAMANFANGSADR.
WSP	EQU	RAMBEG
PRAM	EQU	WSP+257	; PROGRAMMSPEICHERANFADR.
ZFT	EQU	0	; WSP<PRAM
BIN0IO	EQU	1	; BINAERE NULLEN SIND
			; ALS I/O-DATEN MOEGLICH
EXTGO1	EQU	0E003H	; BASIC-Erweiterung 1
EXTGO2	EQU	0E006H	; BASIC-Erweiterung 2
EXTGO3	EQU	0E009H	; BASIC-Erweiterung 3
EXTTAB	EQU	0E00CH	; Token-Tabelle der Erweiterungen
VERT	EQU	0E00EH	; BASIC Programmverteiler
;------------------------------------------------
; CAOS-Vorblock:
	DB	'BASIC   KCC'	; Dateiname
	DS	5,0
	DB	2		; 2 Argumente
	DW	ROMBEG		; Anfangsadresse
	DW	ROMEND		; Endadresse
	DW	0
	DS	95,0
;	DB	'07.01.1987'	; Datum
	DB	'29.05.2021'	; Datum
;---------------
	.PHASE	ROMBEG

.XLIST				; Globale Marken im Absolutmodus nicht erlaubt
;	GLOBAL	DATYPE
;	GLOBAL	EXTFLG
;	GLOBAL	PRTFLG
;	GLOBAL	COLRET
;	GLOBAL	WRA1
;	GLOBAL	DISTAN
;	GLOBAL	PSTBEG
;	GLOBAL	ANF
;	GLOBAL	NANF
;	GLOBAL	ENDE
;	GLOBAL	SVARPT
;-------------------------------------------------
;	GLOBAL	STRDAT
;	GLOBAL	ERROO
;	GLOBAL	SNER
;	GLOBAL	FCER
;	GLOBAL	TCHAR
;	GLOBAL	TCHAR1
;	GLOBAL	PRINT2
;	GLOBAL	CPSTX
;	GLOBAL	CPBRGT
;	GLOBAL	CPCOMM
;	GLOBAL	SNALY
;	GLOBAL	SNALY6
;	GLOBAL	SNLY14
;	GLOBAL	SNLY16
;	GLOBAL	ARGVL1
;	GLOBAL	ARGVL2
;	GLOBAL	EPRVL1
;	GLOBAL	POS1
;	GLOBAL	LEN1
;	GLOBAL	REM
;	GLOBAL	CI
;	GLOBAL	CSTS
;	GLOBAL	STADTB
;	GLOBAL	SADTB1
;	GLOBAL	SLEN0
;	GLOBAL	SLEN3
;	GLOBAL	STRMV1
;	GLOBAL	STROP
;	GLOBAL	STRZS1
;	GLOBAL	STRZS3
;	GLOBAL	WINJP
;	GLOBAL	NUMKON
;	GLOBAL	OPLAD
;	GLOBAL	STOP
;	GLOBAL	CPREG
;	GLOBAL	CPCOMM
;	GLOBAL	DCHEX
;	GLOBAL	DCHEX1
;	GLOBAL	ZPOIT
;	GLOBAL	ZPOIT1
;	GLOBAL	TMEMO1
;	GLOBAL	LIN6
;	GLOBAL	LIN10
;	GLOBAL	LIN11
;	GLOBAL	LIN13
;	GLOBAL	LIN15
;	GLOBAL	SGN1
;	GLOBAL	CLS
;	GLOBAL	PRIST1
;	GLOBAL	SECST
;************************************************
.LIST
; NOTIZSPEICHERVEREINBARUNG	Adresse	Beschreibung (teilweise nach Horst Voelz)
;				-----	----------------------------------------
RSTLOC	EQU	WSP		;0300	Sprungbefehl Warmstart (REBASIC)
USRLOC	EQU	RSTLOC+3	;0303	Sprungbefehl in die USR(X)-Funktion
PORTAD	EQU	USRLOC+3	;0306	Portadresse Variable
IOCHNL	EQU	PORTAD+1	;0307	E/A-Flag
	; Bezeichnung der Bit-Nummern im E/A-Flag
IM_	EQU	0
OM_	EQU	1
IM?	EQU	2
OM?	EQU	3
IM??	EQU	4
OM??	EQU	5
CIM	EQU	6	; unbenutzt?
COM	EQU	7	; unbenutzt?
OUTIND	EQU	IOCHNL+1	;0308	OUT-Index
ININD	EQU	OUTIND+1	;0309	IN-Index
TRFLAG	EQU	ININD+1		;030A	TRACE-Flag
DIVVAR	EQU	TRFLAG+1	;030B	Schnelle SBC-Routine fuer Gleitkommadivision
DVAR1	EQU	DIVVAR+1	;030C	DIV-Variable 1
DVAR2	EQU	DIVVAR+5	;0310	DIV-Variable 2
DVAR3	EQU	DIVVAR+9	;0314	DIV-Variable 3
DVAR4	EQU	DIVVAR+12	;0317	DIV-Variable 4
RNDVR1	EQU	DVAR4+2		;0319	RND-Variable 1
RNDVR2	EQU	RNDVR1+1	;031A	RND-Variable 2
RNDVR3	EQU	RNDVR2+1	;031B	RND-Variable 3
RNDVR4	EQU	RNDVR3+33	;033C	RND-Variable 4
				;1 Byte fuer RNDVR3
				;32 Byte Array mit 8 Konstanten ohne Markennamen
DUMMY	EQU	RNDVR4+4	;0340	Anzahl Dummy-Zeichen (NULL X)
LINLEN	EQU	DUMMY+1		;0341	Ausgabezeilenlaenge
PRLISI	EQU	LINLEN+1	;0342	Anzahl darstellbarer Formate pro Zeile -1
				;	Formatlaenge (13)+1=27
OUTFLG	EQU	PRLISI+1	;0343	Ausgabeunterdrueckung wenn Zelle <> 0
LINFLG	EQU	OUTFLG+1	;0344	Zeilenanzahl fuer List (normal = 10)
LNFLGC	EQU	LINFLG+2	;0346	Kopie von 0344
CHSUML	EQU	LNFLGC+2	;0348	Pruefsumme fuer CLOAD* und CSAVE*
INPLOC	EQU	CHSUML+2	;034A	Eingeberoutine fuer Daten
AUTOFG	EQU	INPLOC+3	;034D	AUTO-Flag
ANF	EQU	AUTOFG+1	;034E	aktuelle Zeilennummer
ENDE	EQU	ANF+2		;0350	Zeilennummer-Abstand
NANF	EQU	ENDE+2		;0352
DISTAN	EQU	NANF+2		;0354
STDPTR	EQU	DISTAN+2	;0356	RAM-Mindestgroesse
CULINO	EQU	STDPTR+2	;0358	aktuelle Zeilennummer
WINJP	EQU	CULINO+2	;035A
DATBYT	EQU	WINJP+3		;035D	1=geschuetzte Datei erzeugen (Kopierschutz)
DATFLG	EQU	DATBYT+1	;035E	1=LIST/EDIT/BYE-Schutz
PSTBEG	EQU	DATFLG+1	;035F	PROGRAMMSTART-ADRESSE
INPBUF	EQU	PSTBEG+2	;0361	EINGABEPUFFERANFANG
EOINPB	EQU	INPBUF+74	;03AB	EINGABEPUFFERENDE
CURPOS	EQU	EOINPB+1	;03AC	CURSORPOSITION
LOCCRE	EQU	CURPOS+1	;03AD	SUCHE VARIABLE (0) ODER FUEGE SIE EIN (1)
DATYPE	EQU	LOCCRE+1	;03AE	DATENTYP
DSTMNT	EQU	DATYPE+1	;03AF	DATA-STATEMENS-FLAG
MEMSIZ	EQU	DSTMNT+1	;03B0	MEMORY SIZE (Speicherende, Anfang Stringraum)
SPTPTR	EQU	MEMSIZ+2	;03B2	ADRESSE DER NAECHSTEN FREIEN STELLE IN LSPT
LSPTBG	EQU	SPTPTR+2	;03B4	SRING-ADRESSTABELLE
EOLSPT	EQU	LSPTBG+11	;03BF	ENDE DER TABELLE
STRDAT	EQU	EOLSPT+1	;03C0	LAENGE UND ADRESSE DES AKTUELLEN STRINGS
SWAPTR	EQU	STRDAT+4	;03C4	ZEIGER FUER STRINGBER.
LBYTEX	EQU	SWAPTR+2	;03C6	INDEX DES ZULETZT ABGEARBEITETEN BYTES
CSTFOR	EQU	LBYTEX+2	;03C8	ADRESSE DES PROGRAMMZEIGERS WAEHREND DER
				;	SUCHE NACH EINER VORHERIGEN FOR-ANWEISUNG
DATPTR	EQU	CSTFOR+2	;03CA	ZEILENNUMMER DES ZULETZT GELESENEN DATASTATEMENTS
FORFLG	EQU	DATPTR+2	;03CC	FOR-FLAG
IPHFLG	EQU	FORFLG+1	;03CD	INPUT-PHASE-FLAG
RDFLAG	EQU	IPHFLG+1	;03CE	RD/WR-FLAG
CUSTMT	EQU	RDFLAG+1	;03CF	ZEILENNUMMER/ADRESSE DES AKTUELLEN STATEMENTS
NTOKPT	EQU	CUSTMT+2	;03D1	ADRESSE DES NAECHSTEN ELEMENTS 
LLNOEX	EQU	NTOKPT+2	;03D3	LETZTE ZEILENNUMMER BEI END/STOP
LBYTER	EQU	LLNOEX+2	;03D5	ADRESSE DES LETZTEN BYTES BEI ERROR
SVARPT	EQU	LBYTER+2	;03D7	ADRESSE DER LISTE DER EINFACHEN- UND STRINGVAR. (Programm-Ende+1)
DVARPT	EQU	SVARPT+2	;03D9	ADRESSE DER LISTE DER FELDVARIABLEN
FSLPTR	EQU	DVARPT+2	;03DB	ERSTE FREIE ADRESSE HINTER DEN Variablen-LISTEN
RDPTR	EQU	FSLPTR+2	;03DD	AKT. ADRESSE IM DATA-STATEMENT WAEHREND READ
FNPTR	EQU	RDPTR+2		;03DF	ADRESSE DES FN-Statements
WRA0	EQU	FNPTR+2		;03E1	ARITHMETIKREGISTER 0
WRA1	EQU	WRA0+4		;03E5	ARITHMETIKREGISTER 1
SGNORS	EQU	WRA1+4		;03E9	VORZEICHEN DER OPERATION
INTPRB	EQU	SGNORS+1	;03EA	PRINT-PUFFER
WRA2	EQU	INTPRB+13	;03F7	ARITHMETIKREGISTER 2
LSTFLG	EQU	WRA2+4		;03FB	Listen-Flag (Status) 0=Grundliste; 1=Erweiterung
EXTFLG	EQU	LSTFLG+1	;03FC	Erweiterungsflag, 0 = Erweiterung nicht vorhanden
PRTFLG	EQU	EXTFLG+1	;03FD	PRINT-Erweiterungsflag, 0 = ohne PRINT-Erweiterung
COLRET	EQU	PRTFLG+1	;03FE	Farbbyte
 
;STEUERZEICHENVEREINBARUNG bzw. Tastencodes
ASCBEL	EQU	07H	;BEEP
ASCCR	EQU	0DH	;CR bzw. Enter-Taste
ASCSP	EQU	20H	;Leerzeichen
CURLFT	EQU	8	;Cursor nach links
CURRGT	EQU	9	;Cursor nach rechts
CURDEL	EQU	1FH	;DEL = Zeichen loeschen
CURSP	EQU	1AH	;INS = Zeichen einfuegen
CURDWN	EQU	0AH	;Cursor nach unten
CURHIG	EQU	0BH	;Cursor nach oben
CURRE	EQU	18H	;Shift+Cursor rechts
CURLI	EQU	19H	;Shift+Cursor links
CLLN	EQU	2	;Shift+DEL
LISTSW	EQU	1CH	;LIST-Taste
RUNSW	EQU	1DH	;RUN-Taste
PAUSSW	EQU	13H	;PAUSE-Taste
STOPSW	EQU	03H	;BRK-Taste
CONTSW	EQU	1EH	;CONTINUE-Taste
*EJECT
;	ORG	ROMBEG
 
BA:	JR	PRIST1	;NEUSTART DES INTERPRETERS
	JP	SECST	;RESTART  --"--
;-------------------------------
	DEFW	7F7FH
	DEFM	'BASIC'
	DEFB	0
;-------------------------------
PRIST1:
;LADE DIE ERSTEN 98 SPEICHERPLAETZE DES
;NOTIZSPEICHERS MIT ERSTBELEGUNG
;RESERVIERE EIN STACKNIVEAU
LDWSP:	
	LD	HL,RAMST
	LD	DE,WSP
	LD	BC,PSTBEG-RSTLOC+8
	LDIR
	EX	DE,HL
	LD	SP,HL
	CALL	INITR		; Stackpointer auf obere RAM-Grenze einstellen
	LD	(EOINPB),A
	LD	(PRAM-1),A
;RESERVIERE ARBEITSRAMBEREICH
RESSP:	LD	HL,MEMO		; HC-BASIC
	CALL	TEXTO
	LD	HL,MEMSZ	; MEMORY END ?
	CALL	TEXTO
	CALL	EING		; Eingabe Speicherende
	LD	HL,INPBUF+1	; Eingabepuffer
	CALL	DCHEX		; Erfassen der eingegebenen Dezimalzahl
	LD	A,D
	SUB	6		;H(RAMBEG)+3
	LD	HL,RAMBEG
	DEC	HL
	JR	NC,RAMSH1
RAMSCH:	LD	DE,ROMBEG-1
;SELBSTTAETIGE RAM-SUCHE BIS MAX. <DE>
RAMSH1:	INC	HL
	CALL	CPREG
	JR	Z,RAMTST
	LD	A,(HL)
	LD	B,A
	CPL
	LD	(HL),A
	CP	(HL)
	LD	(HL),B
	JR	Z,RAMSH1
	DEC	HL
RAMTST:	LD	DE,-256
	LD	(MEMSIZ),HL
	ADD	HL,DE
	LD	(STDPTR),HL
	CALL	NEW1
	LD	HL,(STDPTR)
	LD	DE,-PRAM-16
	ADD	HL,DE
;QUITTIEREN DES ERFOLGREICHEN STARTS
	CALL	NUMBO
	LD	HL,BYT
	CALL	TEXTO
;
; Test, ob Erweiterungen vorhanden sind. Dazu wird der Inhalt der
; Speicherzelle gelesen, auf die E004H zeigt. Wenn BASIC-Erweiterungen
; vorhanden sind, dann beginnen diese mit LD A,B = 78H
;
	LD	HL,(EXTGO1+1)
	LD	A,(HL)
	CP	78H		; Befehl LD A,B
	JR	NZ,RAMSH0
	DEFB	3EH		; LD A,0AFH - Erweiterungen vorhanden
RAMSH0:	XOR	A		; A=0	    - keine Erweiterungen
	LD	(EXTFLG),A
	LD	SP,INPBUF+6
	JR	SECST
;WARMSTART DES INTERPRETERS
;--------------------------------
	DEFW	7F7FH
	DEFM	'REBASIC'
	DEFB	0
;--------------------------------
SECST:	CALL	INITR		; Stackpointer auf obere RAM-Grenze einstellen
	JP	EDIT
 
MEMO:	DEFB	0CH		;CLS
	DEFW	0D0AH
	DEFM	'KC-BASIC'	; Original: HC-BASIC
	DEFW	0D0AH
	DEFB	0
BYT:	DEFM	' BYTES FREE'
	DEFW	0D0AH
	DEFB	0
MEMSZ:	DEFM	'MEMORY END ? :'
	DEFB	0
*EJECT
;NOTIZSPEICHER ERSTBELEGUNG
RAMST:	;JP	SECST-3	;RSTLOC
;
; 29.05.2021: Sprungziel BASIC-Warmstart von SECST-3 zu SECST geaendert.
; Warum das urspruenglich drei Byte davor geht, ist nicht bekannt.
; Macht keinen Sinn, jedoch auch keinen Schaden.
;
	JP	SECST	;RSTLOC
	JP	FCER	;USRLOC
	DEFB	0	;PORTAD	;TORADRESSE VARIABEL
	DEFB	0	;IOCHNL ;E/A-FLAG
	DEFB	0	;OUTIND	;OUTINDEX
	DEFB	0	;ININD	;ININDEX
	DEFB	0	;TRFLAG	;TRACE-FLAG
	SUB	0	;DIVVAR	;SUB VAR.
			;FOR DIV;DVAR1
	LD	L,A
	LD	A,H
	SBC	A,0	;DVAR2
	LD	H,A
	LD	A,B
	SBC	A,0	;DVAR3
	LD	B,A
	LD	A,0	;DVAR4
	RET

	DEFB	0	;RNDVR1		Zaehler 0..170
	DEFB	0	;RNDVR2		Index fuer 3 Konstanten im ROM (RNDL)
	DEFB	0	;RNDVR3		Index fuer 8 Konstanten im WSP (RNDVR3+1)
	DEFW	4A35H	;-2.65145*10E+7
	DEFW	99CAH
	DEFW	1C39H	; 1.61291*10E+7
	DEFW	9876H
	DEFW	9522H	;-1.17691*10E+7
	DEFW	98B3H
	DEFW	0DD0AH	; 1.30983*10E+7
	DEFW	9847H
	DEFW	0D153H	;-2.01612*10E+7
	DEFW	9999H
	DEFW	1A0AH	;-1.04269*10E+7
	DEFW	989FH
	DEFW	0BC65H	;-1.34831*10E+7
	DEFW	98CDH
	DEFW	77D6H	; 1.24825*10E+7
	DEFW	983EH
	DEFW	0C752H	;RNDVR4	;.811635	zuletzt mit RND erzeugte Zahl
	DEFW	804FH
	DEFB	11	;DUMMY	;ANZAHL DER DUMMY-ZEICHEN +1
	DEFB	255	;LINLEN	;AUSGABEZEILENLAENGE
	DEFB	27	;PRLISI	;(ANZAHL DER DARSTELLBAREN FORMATE PRO ZEILE -1)*
			;FORMATLAENGE (13) + 1
	DEFB	0	;OUTFLG	;AUSGABEUNTERDRUECKUNG WENN <> 0
	DEFW	10	;LINFLG	;ZEILENANZAHL FUER LIST
	DEFW	10	;LNFLGC	;COPY VON LINFLG
	DEFW	0	;CHSUML	;PRUEFSUMME FUER CSAVE* UND CLOAD*
	JP	EING	;INPLOC	;EINGABEROUTINE FUER DATEN
	DEFB	0	;AUTOFG	;AUTO-FLAG
	DEFW	0	;ANF	;AKT. ZEILENNUMMER
	DEFW	0	;ENDE	;ZEILENNR.-ABSTAND
	DEFW	0	;NANF
	DEFW	0	;DISTAN
	DEFW	PRAM+100;STDPTR	;RAM-MINDESTGROESSE
			;UNTERE STRINGBEREICHSADRESSE
	DEFW	65534	;CULINO	;AKT. ZEILENNUMMER
	DEFW	0	;WINJP
	DEFB	0C9H
	DEFW	0	;DATBYT,DATFLG
	DEFW	PRAM	;PSTBEG	;PROGRAMMADRESSE
	DEFW	0	;INPBUF-INITIALISIERUNG
	DEFB	0
;****************************
;LISTE DER RESERVIERTEN WORTE, ABGESCHLOSSEN MIT 80H
MNEMTB:	DEFB	'E'+80H		;80H
	DEFM	'ND'
ENDTOK	EQU	80H
	DEFB	'F'+80H		;81H
	DEFM	'OR'
FORTOK	EQU	81H
	DEFB	'N'+80H		;82H
	DEFM	'EXT'
NEXTOK	EQU	82H
	DEFB	'D'+80H		;83H
	DEFM	'ATA'
DATTOK	EQU	83H
	DEFB	'I'+80H		;84H
	DEFM	'NPUT'
INPTOK	EQU	84H
	DEFB	'D'+80H		;85H
	DEFM	'IM'
DIMTOK	EQU	85H
	DEFB	'R'+80H		;86H
	DEFM	'EAD'
REATOK	EQU	86H
	DEFB	'L'+80H		;87H
	DEFM	'ET'
LETTOK	EQU	87H
	DEFB	'G'+80H		;88H
	DEFM	'OTO'
GTOTOK	EQU	88H
	DEFB	'R'+80H		;89H
	DEFM	'UN'
RUNTOK	EQU	89H
	DEFB	'I'+80H		;8AH
	DEFM	'F'
IFTOK	EQU	8AH
	DEFB	'R'+80H		;8BH
	DEFM	'ESTORE'
RSTTOK	EQU	8BH
	DEFB	'G'+80H		;8CH
	DEFM	'OSUB'
GSBTOK	EQU	8CH
	DEFB	'R'+80H		;8DH
	DEFM	'ETURN'
RETTOK	EQU	8DH
	DEFB	'R'+80H		;8EH
	DEFM	'EM'
REMTOK	EQU	8EH
	DEFB	'S'+80H		;8FH
	DEFM	'TOP'
STOTOK	EQU	8FH
	DEFB	'O'+80H		;90H
	DEFM	'UT'
OUTTOK	EQU	90H
	DEFB	'O'+80H		;91H
	DEFM	'N'
ONTOK	EQU	91H
	DEFB	'N'+80H		;92H
	DEFM	'ULL'
NULTOK	EQU	92H
	DEFB	'W'+80H		;93H
	DEFM	'AIT'
WAITOK	EQU	93H
	DEFB	'D'+80H		;94H
	DEFM	'EF'
DEFTOK	EQU	94H
	DEFB	'P'+80H		;95H
	DEFM	'OKE'
POKTOK	EQU	95H
	DEFB	'D'+80H		;96H
	DEFM	'OKE'
DOKTOK	EQU	96H
	DEFB	'A'+80H		;97H
	DEFM	'UTO'
AUTTOK	EQU	97H
	DEFB	'L'+80H		;98H
	DEFM	'INES'
LINTOK	EQU	98H
	DEFB	'C'+80H		;99H
	DEFM	'LS'
CLSTOK	EQU	99H
	DEFB	'W'+80H		;9AH
	DEFM	'IDTH'
WIDTOK	EQU	9AH
	DEFB	'B'+80H		;9BH
	DEFM	'YE'
BYETOK	EQU	9BH
	DEFB	'!'+80H		;9CH
RMTOK	EQU	9CH
	DEFB	'C'+80H		;9DH
	DEFM	'ALL'
CALTOK	EQU	9DH
	DEFB	'P'+80H		;9EH
	DEFM	'RINT'
PNTTOK	EQU	9EH
	DEFB	'C'+80H		;9FH
	DEFM	'ONT'
CONTOK	EQU	9FH
	DEFB	'L'+80H		;A0H
	DEFM	'IST'
LISTOK	EQU	0A0H
	DEFB	'C'+80H		;A1H
	DEFM	'LEAR'
CLETOK	EQU	0A1H
	DEFB	'C'+80H		;A2H
	DEFM	'LOAD'
CLOTOK	EQU	0A2H
	DEFB	'C'+80H		;A3H
	DEFM	'SAVE'
CSATOK	EQU	0A3H
	DEFB	'N'+80H		;A4H
	DEFM	'EW'
NEWTOK	EQU	0A4H
	DEFB	'T'+80H		;A5H
	DEFM	'AB('
TABTOK	EQU	0A5H
	DEFB	'T'+80H		;A6H
	DEFM	'O'
TOTOK	EQU	0A6H
	DEFB	'F'+80H		;A7H
	DEFM	'N'
FNTOK	EQU	0A7H
	DEFB	'S'+80H		;A8H
	DEFM	'PC('
SPCTOK	EQU	0A8H
	DEFB	'T'+80H		;A9H
	DEFM	'HEN'
THNTOK	EQU	0A9H
	DEFB	'N'+80H		;AAH
	DEFM	'OT'
NOTTOK	EQU	0AAH
	DEFB	'S'+80H		;ABH
	DEFM	'TEP'
STPTOK	EQU	0ABH
	DEFB	'+'+80H		;ACH
PLUTOK EQU	0ACH
	DEFB	'-'+80H		;ADH
MINTOK	EQU	0ADH
	DEFB	'*'+80H		;AEH
MULTOK	EQU	0AEH
	DEFB	'/'+80H		;AFH
DIVTOK	EQU	0AFH
	DEFB	'^'+80H		;B0H
RPOTOK	EQU	0B0H
	DEFB	'A'+80H		;B1H
	DEFM	'ND'
ANDTOK	EQU	0B1H
	DEFB	'O'+80H		;B2H
	DEFM	'R'
ORTOK	EQU	0B2H
	DEFB	'>'+80H		;B3H
GRTTOK	EQU	0B3H
	DEFB	'='+80H		;B4H
EQUTOK	EQU	0B4H
	DEFB	'<'+80H		;B5H
LTHTOK	EQU	0B5H
	DEFB	'S'+80H		;B6H
	DEFM	'GN'
SGNTOK	EQU	0B6H
	DEFB	'I'+80H		;B7H
	DEFM	'NT'
INTTOK	EQU	0B7H
	DEFB	'A'+80H		;B8H
	DEFM	'BS'
ABSTOK	EQU	0B8H
	DEFB	'U'+80H		;B9H
	DEFM	'SR'
USRTOK	EQU	0B9H
	DEFB	'F'+80H		;BAH
	DEFM	'RE'
FRETOK	EQU	0BAH
	DEFB	'I'+80H		;BBH
	DEFM	'NP'
INTOK	EQU	0BBH
	DEFB	'P'+80H		;BCH
	DEFM	'OS'
POSTOK	EQU	0BCH
	DEFB	'S'+80H		;BDH
	DEFM	'QR'
SQRTOK	EQU	0BDH
	DEFB	'R'+80H		;BEH
	DEFM	'ND'
RNDTOK	EQU	0BEH
	DEFB	'L'+80H		;BFH
	DEFM	'N'
LNTOK	EQU	0BFH
	DEFB	'E'+80H		;C0H
	DEFM	'XP'
EXPTOK	EQU	0C0H
	DEFB	'C'+80H		;C1H
	DEFM	'OS'
COSTOK	EQU	0C1H
	DEFB	'S'+80H		;C2H
	DEFM	'IN'
SINTOK	EQU	0C2H
	DEFB	'T'+80H		;C3H
	DEFM	'AN'
TANTOK	EQU	0C3H
	DEFB	'A'+80H		;C4H
	DEFM	'TN'
ATNTOK	EQU	0C4H
	DEFB	'P'+80H		;C5H
	DEFM	'EEK'
PEKTOK	EQU	0C5H
	DEFB	'D'+80H		;C6H
	DEFM	'EEK'
DEKTOK	EQU	0C6H
	DEFB	'P'+80H		;C7H
	DEFM	'I'
PITOK	EQU	0C7H
	DEFB	'L'+80H		;C8H
	DEFM	'EN'
LENTOK	EQU	0C8H
	DEFB	'S'+80H		;C9H
	DEFM	'TR$'
STRTOK	EQU	0C9H
	DEFB	'V'+80H		;CAH
	DEFM	'AL'
VALTOK	EQU	0CAH
	DEFB	'A'+80H		;CBH
	DEFM	'SC'
ASCTOK	EQU	0CBH
	DEFB	'C'+80H		;CCH
	DEFM	'HR$'
CHRTOK	EQU	0CCH
	DEFB	'L'+80H		;CDH
	DEFM	'EFT$'
LFTTOK	EQU	0CDH
	DEFB	'R'+80H		;CEH
	DEFM	'IGHT$'
RGTTOK	EQU	0CEH
	DEFB	'M'+80H		;CFH
	DEFM	'ID$'
MIDTOK	EQU	0CFH
	DEFB	'L'+80H		;D0H
	DEFM	'OAD'
LODTOK	EQU	0D0H
	DEFB	'T'+80H		;D1H
	DEFM	'RON'
TRNTOK	EQU	0D1H
	DEFB	'T'+80H		;D2H
	DEFM	'ROFF'
TRFTOK	EQU	0D2H
	DEFB	'E'+80H		;D3H
	DEFM	'DIT'
EDITOK	EQU	0D3H
	DEFB	'E'+80H		;D4H
	DEFM	'LSE'
ELSTOK	EQU	0D4H
	DEFB	80H
LAST	EQU	ELSTOK
;
;ADRESSLISTE DER UNTERPROGRAMME FUER KOMMANDOS
;(DIRECT MODE MOEGLICH)
ADRTB1:	DEFW	END
	DEFW	FOR
	DEFW	NEXT
	DEFW	DATA
	DEFW	INPUT
	DEFW	DIM
	DEFW	READ
	DEFW	LET
	DEFW	GOTO
	DEFW	RUN
	DEFW	IF
	DEFW	RESTO
	DEFW	GOSUB
	DEFW	RETUR
	DEFW	REM
	DEFW	STOP
	DEFW	OUT
	DEFW	ON
	DEFW	NULL
	DEFW	WAIT
	DEFW	DEF
	DEFW	POKE
	DEFW	DOKE
	DEFW	AUTO
	DEFW	LINES
	DEFW	CLS
	DEFW	WIDTH
	DEFW	MONI
	DEFW	REM
	DEFW	CALL
	DEFW	PRINT
	DEFW	CONT
	DEFW	LIST
	DEFW	CLEAR
	DEFW	CLOAD
	DEFW	CSAVE
	DEFW	NEW
	DEFW	LOAD
	DEFW	TRON
	DEFW	TROFF
	DEFW	EDITOR
	DEFW	ELSE
 
;ADRESSLISTE DER UNTERPROGRAMME FUER STANDARDFUNKTIONEN
ADRTB2:	DEFW	SGN
	DEFW	INT
	DEFW	ABS
	DEFW	USRLOC
	DEFW	FRE
	DEFW	INP
	DEFW	POS
	DEFW	SQR
	DEFW	RND
	DEFW	LOG
	DEFW	EXP
	DEFW	COS
	DEFW	SIN
	DEFW	TAN
	DEFW	ATN
	DEFW	PEEK
	DEFW	DEEK
	DEFW	PI
	DEFW	LEN
	DEFW	STR_
	DEFW	VAL
	DEFW	ASC
	DEFW	CHR_
	DEFW	LEFT_
	DEFW	RGHT_
	DEFW	MID_
 
;LISTE DER ADRESSEN FUER DIE UNTERPROGRAMME
;DER ARITHMETIK MIT WICHTUNGSKOEFFIZIENTEN
ADRTB3:	DEFB	79H
	DEFW	PLUS
	DEFB	79H
	DEFW	MINUS
	DEFB	7CH
	DEFW	MUL
	DEFB	7CH
	DEFW	DIV
	DEFB	7FH
	DEFW	EXPO
	DEFB	50H
	DEFW	AND
	DEFB	46H
	DEFW	OR
;
;FEHLERAUSGABE UND RAMTEST
ERRTAB:	DEFM	'NFSNRGODFCOVOMULBSDD'
	DEFM	'/0IDTMOSLSSTCNUFMO'
	DEFM	'IO'
ERR:	DEFM	' ERROR'
	DEFW	ASCBEL
IN:	DEFM	' IN '
	DEFB	00H
FILE:	DEFM	'FILE FOUND'
	DEFB	ASCCR
OK:	DEFM	'OK'
	DEFW	ASCCR
BR:	DEFM	'BREAK'
	DEFB	0
 
;TEST, OB RAM FUER DIE NAECHSTEN OPERATIONEN AUSREICHT
TMEMO:	PUSH	HL		;NEUER ZUSAETZLICHER
	LD	HL,(FSLPTR)	;RAMBEDARF  2*(C)
	LD	B,0
	ADD	HL,BC
	ADD	HL,BC
	DEFB	3EH
TMEMO1:	PUSH	HL		;AKTIVIERTER RAM UND
	LD	A,208		;AKTUELLER SP MUESSEN
	SUB	L		;MINDESTENS 49 BYTES
	LD	L,A		;AUSEINANDER LIEGEN,
	LD	A,-1		;SONST OM-ERROR
	SBC	A,H
	JR	C,OMER		; -> OM ERROR
	LD	H,A
	ADD	HL,SP
	POP	HL
	RET	C
;ORGANISATION DER FEHLERAUSGABE
;FEHLERNUMMER IN REGISTER E
OMER:	LD	E,12		; OM-ERROR
	JR	ERROO
	;
SNER0:	LD	HL,(DATPTR)
	LD	(CULINO),HL	; aktuelle Zeilennummer
SNER:	LD	E,2		; SN-ERROR
	DEFB	01H
DIVER:	LD	E,20		; /0-ERROR
	DEFB	01H
NFER:	LD	E,0		; NF-ERROR
	DEFB	01H
DDER:	LD	E,18		; DD-ERROR
	DEFB	01H
UFER:	LD	E,34		; UF-ERROR
 
;AUSGABE DES FEHLERKODE
ERROO:	CALL	INITR		; Stackpointer auf obere RAM-Grenze einstellen
	LD	(OUTFLG),A	; OUTPUT ENABLE
	CALL	CRWDY		; neue Zeile
	LD	HL,ERRTAB
	LD	D,A
	ADD	HL,DE
	LD	B,H
	LD	C,L
	DEC	BC
	LD	A,'?'		; als Erstes ein Fragezeichen
	LD	E,3		; insgesamt 3 Zeichen
	CALL	TEXTO3		; anzeigen
ERROO2:	LD	HL,ERR		; ERROR + Beep
ERROO1:	CALL	TEXTO		; anzeigen
	LD	HL,(CULINO)	; aktuelle Zeilennummer
	LD	DE,65534	; Startwert bei Initialisiereun
	CALL	CPREG
	JP	Z,PRIST1	;SPRUNG, WENN FEHLER BEI DER EIONGABE
				;DES RAMBEREICHS BEIM KALTSTART
	LD	A,H
	AND	L		; HL=FFFFh im Direktmode
	INC	A		; Direktmode?
	CALL	NZ,INOUT	; "IN Zeilennummer" anzeigen
	DEFB	3EH
;
;EDITIERROUTINE/KOMMANDOEBENE
EDIT0:	POP	BC
EDIT:	XOR	A
	LD	(OUTFLG),A	; Ausgabe nicht unterdruecken
	CALL	CRWDY		; neue Zeile
	LD	HL,OK
	CALL	TEXTO		; OK-Meldung
	SCF			; alle Kanaele schliessen
;ZEILENEINGABE
LININP:	CALL	C,CLCHNL	; alle benutzten Kanaele schliessen, sowie
				; Tastatur/Bildschirm als E/A-Kanal einstellen
	CALL	INPINI		; Eingabepuffer initialisieren
	DEC	HL		; -1
	LD	(CULINO),HL	; aktuelle Zeilennummer = Direktmode
	LD	HL,INTPRB
	LD	A,(AUTOFG)
	OR	A		; Automatische Zeilennummerierung aktiv?
	JR	Z,LIN4		; nein
	LD	DE,(ANF)	; aktuelle Zeilennummer
	JP	P,EDITO1
	PUSH	DE
	CALL	NUMBO1		; Nummer anzeigen
	POP	DE
	PUSH	DE
	CALL	ZPOIT
	LD	A,'*'		; Zeile bereits vorhanden
	JR	C,LIN1
	LD	A,' '		; Zeile noch nicht vorhanden
LIN1:	CALL	CHARO
	CALL	EING		; Zeileneingabe bei AUTO=aktiv
	POP	DE
	JR	NC,LIN3		; nicht BRK sondern Enter
LIN2:	XOR	A
	LD	(AUTOFG),A	; AUTO deaktivieren
	JR	EDIT
	;
LIN3:	LD	HL,(ENDE)	; Zeilennummer Abstand
	ADD	HL,DE		; zu aktueller Zeilennummer addieren
	JR	C,LIN2		; Ueberlauf
	PUSH	DE
	LD	DE,65529
	CALL	CPREG
	POP	DE
	JR	NC,LIN2		; zu gross
	LD	(ANF),HL	; neue Zeilennummer
LIN16:	LD	HL,INPBUF+1
	PUSH	AF
	JR	LIN5
	;
EDITOR:	RET	Z
	CALL	IOTEST		; EDIT-Schutz gesetzt?
	CALL	DCHEX
	RET	NZ
	POP	BC
EDITO1:	CALL	ZPOIT
	JR	NC,LIN15
	PUSH	DE
	LD	A,(HL)
	INC	HL
	OR	(HL)
	INC	HL
	JR	Z,EDITO2
	LD	A,7FH
EDITO2:	LD	(AUTOFG),A
	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A
	LD	(ANF),HL
	CALL	LINEDI
	POP	DE
	JP	NZ,LININP
	JR	C,LIN2
	CCF
	JR	LIN16
	;
LIN4:	LD	A,'>'		; Prompt-Zeichen
	CALL	CHARO		; Eingabebereitschaft anzeigen
	CALL	EING		; Eingabe einer Zeile
	JP	C,LININP	; BRK -> Eingabe ignorieren
	LD	HL,INPBUF	; Eingabepuffer
	CALL	TCHAR		; erstes Zeichen holen
	INC	A
	DEC	A
	JP	Z,LININP	; leere Eingabezeile
	PUSH	AF
;ZEILENNUMMER PRUEFEN UND IN HEXZAHL WANDELN
	CALL	DCHEX		; Dezimalzahl erfassen
LIN5:	PUSH	DE
;EINGABEZEILE IN VERKUERZTE DARSTELLUNG WANDELN
	CALL	SCANN
	LD	B,A
	POP	DE
	POP	AF
;UNTERPROGRAMMADRESSE FUER KOMMANDO BILDEN
;UND KOMMANDO AUSFUEHREN, WENN KEINE ZEILEN
;NUMMER VORHANDEN IST
	JP	NC,RUNMD2	;DIRECTMODE
	PUSH	DE
	PUSH	BC
	XOR	A
	LD	(IPHFLG),A
;TEST, OB DER ZEILENNUMMER WEITERE ZEICHEN FOLGEN
	CALL	TCHAR
	OR	A
LIN13:	PUSH	AF
;ZEIGER (IN REGISTER HL) AUF ZEILE MIT DER
;NAECHSTGRRESSEREN ZEILENNUMMER STELLEN
	CALL	ZPOIT
	JR	C,LIN6
	POP	AF
	PUSH	AF
	OR	A
	JR	NZ,LIN6
;SPRUNG ZUR FEHLERAUSGABE, WENN ZU LOESCHENDE
;ZEILE IM PROGRAMM NICHT VORHANDEN IST
LIN15:	JP	ULER
;EINSORTIEREN DER EINGEGEBENEN ZEILE IN DAS
;SCHON IM RAM VORHANDENE PROGRAMM
LIN6:	PUSH	BC
	JR	NC,LIN8
LIN14:	EX	DE,HL
	LD	HL,(SVARPT)
LIN7:	LD	A,(DE)
	LD	(BC),A
	INC	BC
	INC	DE
	CALL	CPREG
	JR	NZ,LIN7
	LD	(SVARPT),BC
LIN8:	POP	DE
	POP	AF
	JR	Z,LIN10
	LD	HL,(SVARPT)
	EX	(SP),HL
	POP	BC
	ADD	HL,BC
	PUSH	HL
	CALL	LININ
	POP	HL
	LD	(SVARPT),HL
	EX	DE,HL
	LD	(HL),-1
	POP	DE
	INC	HL
	INC	HL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	INC	HL
	LD	DE,INPBUF+1
LIN9:	LD	A,(DE)
	LD	(HL),A
	INC	HL
	INC	DE
	OR	A
	JR	NZ,LIN9
LIN10:	CALL	NEW2
	INC	HL
	EX	DE,HL
	LD	HL,LININP
	PUSH	HL
LIN11:	LD	H,D
	LD	L,E
	LD	A,(HL)
	INC	HL
	OR	(HL)
	RET	Z
	INC	HL
	LD	A,(HL)
	INC	HL
	AND	(HL)
	INC	A
	RET	Z
	INC	HL
	XOR	A
LIN12:	CP	(HL)
	INC	HL
	JR	NZ,LIN12
	EX	DE,HL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	JR	LIN11
;ZEILE EINFUEGEN
LININ:	CALL	TMEMO1
LININ1:	PUSH	BC
	EX	(SP),HL
	POP	BC
LININ2:	CALL	CPREG
	LD	A,(HL)
	LD	(BC),A
	RET	Z
	DEC	BC
	DEC	HL
	JR	LININ2
 
;ZEIGER AUF ANFANG DER ZEILE MIT DER NAECHST-
;GROESSEREN ZEILENNUMMER STELLEN
;Z-FLAG=1 und CY=1, WENN ZEILENNUMMER SCHON VORHANDEN
ZPOIT:	LD	HL,(PSTBEG)	; Programmstart-Adresse
ZPOIT1:	LD	B,H
	LD	C,L
	LD	A,(HL)
	INC	HL
	OR	(HL)
	DEC	HL
	RET	Z
	INC	HL
	INC	HL
	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A
	CALL	CPREG
	LD	H,B
	LD	L,C
	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A
	CCF
	RET	Z
	CCF
	RET	NC
	JR	ZPOIT1
;
;UMWANDLUNG DER EINGEGEBENEN ZEICHENKETTE IN
;INTERNE (VERKUERZTE) DARSTELLUNG
;DIESE DARSTELLUNG IM EINGABEPUFFER ABLEGEN
SCANN:	XOR	A
	LD	(DSTMNT),A
	LD	C,5
	LD	DE,INPBUF+1
SCANN1:	XOR	A
	LD	(LSTFLG),A	;Erweiterungsliste noch nicht durch
	LD	A,(HL)
	CP	' '
	JP	Z,SCANN9
	LD	B,A
	CP	'"'
	JP	Z,SCANND
	OR	A
	JP	Z,SCANNE
	LD	A,(DSTMNT)
	OR	A
	LD	A,(HL)
	JR	NZ,SCANN9
	CP	'?'
	LD	A,PNTTOK
	JR	Z,SCANN9
	LD	A,(HL)
	CP	'0'
	JR	C,DCLI0
	CP	'<'
	JR	C,SCANN9
;TEST, OB EINGEGEBENE ZEICHENKETTE IN DER LISTE
;DER RESERVIERTEN WORTE ENTHALTEN IST
;MERKE STELLE IN DER LISTE
DCLI0:	PUSH	DE
	LD	DE,MNEMTB-01H
	PUSH	BC
	LD	BC,SCANN8
	PUSH	BC
;UMWANDLUNG EINGEGEBENER KLEIN- IN GROSSBUCHSTABEN
	LD	B,ENDTOK-1
	LD	A,(HL)
	CP	'a'
	JR	C,SCANN2
	CP	'z'+1
	JR	NC,SCANN2
	AND	5FH
	LD	(HL),A
SCANN2:	LD	C,(HL)
	EX	DE,HL
;STELLE ZEIGER AUF NAECHSTEN WORTANFANG  
SCANN3:	INC	HL
	OR	(HL)
	JP	P,SCANN3
	INC	B
	LD	A,(HL)
;TEST AUF LISTENENDE
	AND	7FH
	JR	NZ,SCANNF	;Listenende noch nicht erreicht
	LD	A,(EXTFLG)
	AND	A
	RET	Z
	LD	A,(LSTFLG)
	AND	A
	RET	NZ
	INC	A
	LD	(LSTFLG),A
	LD	HL,(EXTTAB)	; Token-Tabelle der Erweiterungen
	LD	A,(HL)
	AND	7FH		; Listenende der Erweiterungstabelle?
	RET	Z
;TEST AUF UEBEREINSTIMMUNG DES 1. ZEICHENS
SCANNF:	CP	C
	JR	NZ,SCANN3
	EX	DE,HL
	PUSH	HL
SCANN4:	INC	DE
	LD	A,(DE)
	OR	A
;SPRUNG, WENN WORT VOLLSTAENDIG IDENTIFIZIERT
	JP	M,SCANN7
	LD	C,A
	LD	A,B
	CP	GTOTOK
	JR	NZ,SCANN5
	CALL	TCHAR
	DEC	HL
SCANN5:	INC	HL
	LD	A,(HL)
;UMWANDLUNG EINGEGEBENER KLEIN- IN GROSSBUCHSTABEN
	CP	'a'
	JR	C,SCANN6
	AND	5FH
;TEST AUF UEBEREINSTIMMUNG DES 2.,3....ZEICHENS
SCANN6:	CP	C
	JR	Z,SCANN4
	POP	HL
	JR	SCANN2
	;
SCANN7:	LD	C,B
	POP	AF
	EX	DE,HL
	RET
	;
SCANN8:	EX	DE,HL
	LD	A,C
	POP	BC
	POP	DE
SCANN9:	INC	HL
	LD	(DE),A
	INC	DE
	INC	C
	SUB	':'
	JR	Z,SCANNA
	CP	DATTOK-':'
	JR	NZ,SCANNB
SCANNA:	LD	(DSTMNT),A
SCANNB:	SUB	REMTOK-':'
	JR	Z,SCANNG
	SUB	RMTOK-REMTOK
	JP	NZ,SCANN1
SCANNG:	LD	B,A
SCANNC:	LD	A,(HL)
	OR	A
	JR	Z,SCANNE
	CP	B
	JR	Z,SCANN9
SCANND:	INC	HL
	LD	(DE),A
	INC	C
	INC	DE
	JR	SCANNC
	;
SCANNE:	LD	HL,INPBUF
	LD	(DE),A
	INC	DE
	LD	(DE),A
	INC	DE
	LD	(DE),A
	RET
;
; ROUTINE ZUR EINGABE EINER ZEILE UND ABLAGE IM EINGABEPUFFER
; BERUECKSICHTIGUNG DER STEUER- UND SONDERZEICHEN
;
TLIST:	DB	'LIST',0
TRUN:	DB	'RUN',0
TCONT:	DB	'CONT',0
;--------------------------------
EING:	PUSH	HL
	LD	HL,INPBUF+1	; Eingabepuffer
EING1:	EX	(SP),HL
	CALL	CI		; Eingabe ein Zeichen
	EX	(SP),HL
;-------------------------------
	CP	LISTSW		; LIST-Taste? (Code 1CH)
	LD	DE,TLIST-1
	JR	Z,EING2
	CP	RUNSW		; RUN-Taste? (Code 1DH)
	LD	DE,TRUN-1
	JR	Z,EING2
	CP	CONTSW		; CONT-Taste? (Code 1EH)
	LD	DE,TCONT-1
	JR	NZ,EING3
; LIST, RUN, CONT
EING2:	LD	HL,INPBUF
EING4:	INC	HL
	INC	DE
	LD	A,(DE)
	LD	(HL),A
	AND	A
	JR	NZ,EING4
	LD	HL,INPBUF+1
	CALL	TEXTOE
	POP	HL
	JP	CRWDY6
;-----------------------------
EING3:	CALL	ZECR		; CR?
	JR	NZ,EING5	; nein
EING6:	POP	HL
	RET
	;
EING5:	CALL	ZSTOP		; BRK?
	JR	C,EING6		; ja
	CALL	ZEEDI		; Tastaturausgabe auswerten
	JR	EING1		; weiter in Eingaberoutine bleiben
;--------------------------------
TEXTOE:	LD	A,(HL)
	OR	A
	RET	Z
	CALL	CO
	INC	HL
	JR	TEXTOE
;--------------------------------
;
AUTO:	LD	DE,10
	PUSH	DE
	JR	Z,AUTO2
	CALL	DCHEX		; Dezimalzahl erfassen
	EX	DE,HL
	EX	(SP),HL
	JR	Z,AUTO3
	EX	DE,HL
	CALL	CPCOMM
	LD	DE,(ENDE)
	JR	Z,AUTO2
	CALL	DCHEX		; Dezimalzahl erfassen
	JP	NZ,SNER
AUTO2:	EX	DE,HL
AUTO3:	LD	A,L
	OR	H
	JP	Z,FCER
	LD	(ENDE),HL
	SET	7,A
	LD	(AUTOFG),A
	POP	HL
	LD	(ANF),HL
	POP	BC
AUTO4:	JP	LININP
 
LOAD:	CALL	INCHNL
	LD	A,(ININD)	; IN-Index
	AND	OCH_
	JR	Z,AUTO4
	LD	A,D5TYPE
	CALL	CASS1
	POP	AF
	XOR	A
	JR	AUTO4
;
;PROGRAMMENDEZEICHEN AN DEN ANFANG DES PROGRAMM-
;ABLAGERAMBEREICHS RUECKEN UND NOTIZSPEICHER LOESCHEN
NEW:	RET	NZ
NEW1:	LD	HL,(PSTBEG)	; Programmstart-Adresse
	XOR	A
	LD	(DATFLG),A	; LIST/EDIT/BYE-Schutz ruecksetzen
	LD	(HL),A
	INC	HL
	LD	(HL),A
	INC	HL
	LD	(SVARPT),HL	; Programmende+1
NEW2:	LD	HL,(PSTBEG)	; Programmstart-Adresse
	DEC	HL
NEW3:	LD	(CUSTMT),HL	; ZEILENNUMMER/ADRESSE DES AKTUELLEN STATEMENTS
	LD	HL,(MEMSIZ)
	LD	(SWAPTR),HL
	XOR	A
	CALL	RESTO
	LD	HL,(SVARPT)
	LD	(DVARPT),HL
	LD	(FSLPTR),HL
;STACKPOINTER AUF OBERE RAMGRENZE STELLEN
;OBERE STACKBEGRENZUNG EINTRAGEN
INITR:	POP	BC		; RET-Adresse holen
	LD	HL,(STDPTR)
	LD	SP,HL		; SP auf oberen Wert neu setzen
	LD	HL,LSPTBG
	LD	(SPTPTR),HL
	CALL	SETCO
	XOR	A
	LD	L,A
	LD	H,A
	LD	(LBYTER),HL
	LD	(FORFLG),A
	LD	(FNPTR),HL
	PUSH	HL
	PUSH	BC		; RET-Adresse vom alten Stack
INITR2:	LD	HL,(CUSTMT)	; ZEILENNUMMER/ADRESSE DES AKTUELLEN STATEMENTS
	RET
;
;VERGLEICHE INHALT VON REGISTER DE MIT HL
CPREG:	LD	A,H
	SUB	D
	RET	NZ
	LD	A,L
	SUB	E
	RET

;TEST AUF GROSSBUCHSTABEN
CLETST:	LD	A,(HL)
	CP	'A'
	RET	C
	CP	'Z'+1
	CCF
	RET

;TEST AUF ZULAESSIGE IO-OPERATION (DATENSCHUTZ)
IOTEST:	LD	A,(DATFLG)	; LIST/EDIT/BYE-Schutz gesetzt?
	AND	A
	RET	Z
	CALL	INITR		; Stackpointer auf obere RAM-Grenze einstellen
	JP	ERROO2
;
CLFTOU:	CALL	CPREG
	LD	A,CURLFT	;Cursor nach links
	JR	SPOUT1
	;
SPOUT:	LD	A,' '
SPOUT1:	JP	CO
 
;GIB ZEICHEN ZUR AUSGABESCHNITTSTELLE UND ORGANISIERE
;ZEILENLAENGE UND MERKE POSITION DES CURSORS
CHARO:	PUSH	AF
	PUSH	BC
	LD	C,A
	CP	' '
	JR	C,CHARO2	;JP IF IT IS A CONTROL
	LD	A,(LINLEN)	;Zeilenlaenge
	LD	B,A
	LD	A,(CURPOS)
	INC	B
	JR	Z,CHARO1	;JP IF LINLEN = 255
	DEC	B
	CP	B
	CALL	Z,CRWDY2	;CALL IF LINLEN=CURPOS
CHARO1:	INC	A		;INC CURPOS
	LD	(CURPOS),A
CHARO2:	LD	A,C
	CALL	CO
	POP	BC
	POP	AF
	RET

;EINGABEANFORDERUNG STELLEN
OUT?:	LD	A,'?'
	CALL	CHARO
OUT1?:	LD	A,CURRGT	; Cursor nach rechts
	CALL	CHARO
	CALL	INPINI		; Eingabepuffer initialisieren
	JP	INPLOC		; -> JP EING

;Eingabepuffer initialisieren:
INPINI:	LD	HL,2000H
	LD	(INPBUF),HL	;INPBUF:= 00 20 00 20
	LD	(INPBUF+2),HL
	LD	H,L		; HL=0
	RET
;
LINES:	CALL	EPRVL4
	LD	(LNFLGC),DE
	RET

;LISTEN DES IM PROGRAMMSPEICHER BEFINDLICHEN
;PROGRAMMS, AUSGABE UEBER AUSGABESCHNITTSTELLE
LIST:	CALL	IOTEST		; LIST-Schutz gesetzt?
	CALL	OUTCHL		; I/O-Kanal aktivieren
	CALL	TESTCO		; Ausgabe auf Bildschirm?
	JR	Z,LIST0
	LD	A,D5TYPE	; UUU = LIST-Ausgabedatei
	CALL	CASS1
	LD	HL,(LNFLGC)	; Zeilenanzahl fuer LIST
	LD	(ANF),HL	; hier merken
	LD	HL,-1		; maximaler Wert
	LD	(LNFLGC),HL	; fuer Datei vorgeben (ohne Pause)
	POP	HL
LIST0:	CALL	DCHEX		; Dezimalzahl erfassen und in Hex-Zahl umwandeln
	RET	NZ
	POP	BC
	CALL	ZPOIT		; Zeiger auf naechste Zeilennummer
	PUSH	BC
	CALL	LCREG
LIST1:	POP	HL		; Zeiger auf Programmadresse
	LD	C,(HL)
	INC	HL
	LD	B,(HL)		; BC = Adresse der naechsten Zeile
	INC	HL
	LD	A,B
	OR	C
	JR	Z,LIST6		; Programm-Ende
	CALL	LIST9
	CALL	TESC		; TEST AUF UNTERBRECHUNGSANFORDERUNG
	PUSH	BC
	LD	E,(HL)
	INC	HL
	LD	D,(HL)		; DE = Zeilennummer
	INC	HL
	PUSH	HL
	LD	HL,INTPRB	; PRINT-Puffer
	CALL	CRWDY2		; Ausgabe CR, LF, Dummy-Zeichen
	CALL	NUMBO1		; AUSGABE ZEILENNUMMER
	LD	A,' '		; ein Leerzeichen zwischen Zeilennummer und Inhalt
	POP	HL		; Programmzeiger
LIST2:	CALL	CHARO		; AUSGABE ZEILENTEXT
LIST3:	LD	A,(HL)
	INC	HL
	CP	'"'		; Zeichenkette?
	JR	Z,LIST5
	OR	A
	JR	Z,LIST1		; Zeilenende
	JP	P,LIST2		; Gesetztes Bit 7 = Token
	CALL	LIST11		; Token aufloesen
LIST4:	CALL	CHARO		; Token anzeigen
	LD	A,(DE)
	INC	DE
	OR	A
	JP	P,LIST4		; bis zum naechsten gesetzten Bit 7
	JR	LIST3
	;
LIST5:	CALL	CHARO		; Zeichen anzeigen
	LD	A,(HL)
	INC	HL
	OR	A
	JR	Z,LIST1		; bis zum Zeilenende
	CP	'"'
	JR	Z,LIST2		; oder bis zum naechsten "
	JR	LIST5

LIST9:	PUSH	HL		;ZEILEN-ANZAHL-KONTROLLE
	LD	HL,(LINFLG)
	LD	A,L
	OR	H
	DEC	HL
	LD	(LINFLG),HL
	POP	HL
	RET	NZ
	CALL	LCREG
;TEST AUF ANFORDERUNG ZUM BEENDEN DES LISTEN
	CALL	CI
	CP	STOPSW		; BRK-Taste?
	JR	NZ,LIST9
LIST6:	CALL	TESTCO
	JR	Z,LIST7
	CALL	CRWDY2
	CALL	CLCHNL		; alle benutzten Kanaele schliessen
	LD	HL,(ANF)	; gemerkter Wert fuer Zeilenanzahl bei LIST
	LD	(LNFLGC),HL	; wieder regenerieren
LIST7:	JP	SECST
	;
LCREG:	PUSH	HL
	LD	HL,(LNFLGC)
	LD	(LINFLG),HL
	POP	HL
	RET

; 24.01.2021:
; LIST gepatcht, sodass bei Anzeige keine undefinierten Erweiterungstoken mit
; beruecksichtigt werden (bei MC in BASIC-Zeile)

LIST11:	SUB	7FH
	CP	LAST-7FH+1	; Token aus Erweiterungsliste?
	LD	DE,MNEMTB	; interne Token
	JR	C,LIST10
	SUB	LAST-7FH
	LD	DE,(EXTTAB)	; externe Token
LIST10:	LD	B,A		; Position in Tokentabelle
LIST12:	call	patch		; Patch aufrufen
	INC	DE
	OR	A		; Bit 7 gesetzt?
	JP	P,LIST12	; nein, gleicher Token
	DJNZ	LIST12		; naechster Token
	AND	7FH		; Bit 7 zurueck setzen
	RET
;
;TRACEFUNKTION - AUSGABE DER ZEILENNUMMER DER
;IN ABARBEITUNG BEFINDLICHEN ZEILE
TRON:	DEFB	3EH
TROFF:	XOR	A
	LD	(TRFLAG),A
	RET

;ABLAUFSTEUERUNG INTERPRETIERVORGANG
FORSR:	LD	HL,4
	ADD	HL,SP
FORSR1:	LD	A,(HL)
	INC	HL
	CP	FORTOK
	RET	NZ
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	INC	HL
	PUSH	HL
	LD	L,C
	LD	H,B
	LD	A,D
	OR	E
	EX	DE,HL
	JR	Z,FORSR2
	EX	DE,HL
	CALL	CPREG
FORSR2:	LD	BC,13
	POP	HL
	RET	Z
	ADD	HL,BC
	JR	FORSR1
	;
FOR:	LD	A,100
	LD	(FORFLG),A
	CALL	LET
	POP	BC
	PUSH	HL
	CALL	DATA
	LD	(CSTFOR),HL
	LD	HL,2
	ADD	HL,SP
FOR1:	CALL	FORSR1
	POP	DE
	JR	NZ,FOR2
	ADD	HL,BC
	PUSH	DE
	DEC	HL
	LD	D,(HL)
	DEC	HL
	LD	E,(HL)
	INC	HL
	INC	HL
	PUSH	HL
	LD	HL,(CSTFOR)
	CALL	CPREG
	POP	HL
	JR	NZ,FOR1
	POP	DE
	LD	SP,HL
FOR2:	EX	DE,HL
	LD	C,8
	CALL	TMEMO
	PUSH	HL
	LD	HL,(CSTFOR)
	EX	(SP),HL
	PUSH	HL
	LD	HL,(CULINO)	; aktuelle Zeilennummer
	EX	(SP),HL
	CALL	SNALY3
	CALL	CPSTX
	DEFB	TOTOK
	CALL	SNALY2
	PUSH	HL
	CALL	OPLAD0
	POP	HL
	PUSH	BC
	PUSH	DE
	LD	BC,8100H	;+1.0
	LD	D,C
	LD	E,D
	LD	A,(HL)
	CP	STPTOK
	LD	A,1
	JR	NZ,FOR3
	CALL	TCHAR
	CALL	SNALY2
	PUSH	HL
	CALL	OPLAD0
	CALL	TSGNM
	POP	HL
FOR3:	PUSH	BC
	PUSH	DE
	PUSH	AF
	INC	SP
	PUSH	HL
	LD	HL,(CUSTMT)	; ZEILENNUMMER/ADRESSE DES AKTUELLEN STATEMENTS
	EX	(SP),HL
FOR4:	LD	B,FORTOK
	PUSH	BC
	INC	SP
 
;RUN-MODE ORGANISATION
;TEST AUF UNTERBRECHUNGSANFORDERUNG
RUNMOD:	CALL	SETCOI
	CALL	TESC
	LD	(CUSTMT),HL	; ZEILENNUMMER/ADRESSE DES AKTUELLEN STATEMENTS
;TEST AUF FORTSETZUNG DER ZEILE MIT COLON
	LD	A,(HL)
	CP	':'
	JR	Z,RUNMD2
	OR	A
	JP	NZ,SNER
	INC	HL
	LD	A,(HL)
	INC	HL
	OR	(HL)
	JP	Z,END2
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	(CULINO),DE	; aktuelle Zeilennummer
	LD	A,(TRFLAG)
	OR	A
	JR	Z,RUNMD2
	PUSH	HL
	LD	A,'<'
	CALL	CHARO
	CALL	NUMBO1
	LD	A,'>'
	CALL	CHARO
	POP	HL
;TEST AUF ZEILENENDE
RUNMD2:	CALL	TCHAR
	LD	DE,RUNMOD
	PUSH	DE
RUNMD3:	RET	Z
;ERMITTLUNG DER ZU DEN KOMMANDOS IM DIRECT-MODE
;(AUCH IM INDIRECT-MODE VERWENDBAR) GEHOERNDEN
;UNTERPROGRAMMADRESSEN
DCLI2:	SUB	ENDTOK
	JP	C,LET
	CP	TABTOK-ENDTOK
	JR	C,DLI21
	SUB	LODTOK-ENDTOK
	JR	C,CPSTX2
	CP	LAST-LODTOK+1	; Kommando aus Grundliste?
	JR	C,DLI20		; ja
	LD	B,A
	LD	A,(EXTFLG)
	AND	A		; Erweiterung vorhanden?
	JR	Z,CPSTX2	; nein --> Fehler
	JP	EXTGO1		; Absprung zur Erweiterung
	;
DLI20:	ADD	A,TABTOK-ENDTOK
DLI21:	RLCA
	LD	C,A
	LD	B,0
	EX	DE,HL
	LD	HL,ADRTB1	; Adresstabelle Grundtoken
DLI22:	ADD	HL,BC
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	PUSH	BC
	EX	DE,HL
;ZEIGER IN DER ABZUARBEITENDEN ZEILE AUF
;NAECHSTES SIGNIFIKANTES ZEICHEN STELLEN
;TEST AUF ZEILENENDE
TCHAR:	INC	HL
TCHAR1:	LD	A,(HL)
	CP	':'
	RET	NC
	CP	' '
	JR	Z,TCHAR
	CP	'0'
	CCF
	INC	A
	DEC	A
	RET

;VERGLEICHE (HL) MIT ((SP)),ERHOEHE (SP) UM 1
CPSTX:	LD	A,(HL)
	EX	(SP),HL
	CP	(HL)
	INC	HL
	EX	(SP),HL
CPSTX1:	JR	Z,TCHAR
CPSTX2:	JP	SNER
 
CPCOMM:	LD	A,','
CPCOM1:	CP	(HL)
	JR	CPSTX1
	;
CPBRGT:	LD	A,')'
	JR	CPCOM1
;
;REINITIALISIEREN VON DATEN
RESTO:	EX	DE,HL
	LD	HL,(PSTBEG)	; Programmstart-Adresse
	JR	Z,RESTO1
	EX	DE,HL
	CALL	DCHEX		; Dezimalzahl erfassen
	PUSH	HL
	CALL	ZPOIT
	LD	H,B
	LD	L,C
	POP	DE
	JP	NC,ULER
RESTO1:	DEC	HL
RESTO2:	LD	(RDPTR),HL
	EX	DE,HL
	RET
;
; PROGRAMMUNTERBRECHUNG UND -FORTSETZUNG
;
TESC:	CALL	CSTS		; Konsolen(Tastatur-)status abfragen
	RET	NZ		; keine Taste gedrueckt
	CP	PAUSSW		; PAUSE-Taste? (13H = STOP)
	JR	Z,TESC0
	CP	STOPSW		; BRK-Taste? (03H = BRK)
	RET	NZ
	CALL	CI		; BRK-Code abholen von Konsole
	JR	STOP
	;
TESC0:	CALL	CI		; Konsoleneingabe
	CP	CONTSW		; CONTINUE-Taste? (1EH = CONT)
	RET	Z
	CP	CURDWN		; Cursor runter?
	RET	Z
	CP	STOPSW		; BRK-Taste? (03H = BRK)
	JR	Z,STOP
	JR	TESC0
	;
STOP:	RET	NZ
	DEFB	0F6H		; OR n
END:	RET	NZ
END0:	LD	(CUSTMT),HL	; ZEILENNUMMER/ADRESSE DES AKTUELLEN STATEMENTS
	DEFB	21H		; LD HL,nn
END1:	OR	0FFH
	POP	BC
END2:	LD	HL,(CULINO)	; aktuelle Zeilennummer
	PUSH	AF
	LD	A,L
	AND	H
	INC	A
	JR	Z,END3
	LD	(LLNOEX),HL
	LD	HL,(CUSTMT)	; ZEILENNUMMER/ADRESSE DES AKTUELLEN STATEMENTS
	LD	(LBYTER),HL
END3:	XOR	A
	LD	(OUTFLG),A	; Ausgabe nicht unterdruecken
	CALL	SETCO
	CALL	CRWDY		; neue Zeile
	POP	AF
	LD	HL,BR
	JP	NZ,ERROO1
	JP	EDIT
 
CONT:	LD	HL,(LBYTER)
	LD	A,H
	OR	L
CNER:	LD	E,32		; CN-ERROR
	JP	Z,ERROO
	EX	DE,HL
	LD	HL,(LLNOEX)
	LD	(CULINO),HL	; aktuelle Zeilennummer
	EX	DE,HL
	RET
;
;BESTIMMEN DES WERTES EINES AUSDRUCKS
EPRVAL:	CALL	TCHAR
EPRVL1:	CALL	SNALY2
EPRVL2:	CALL	TSGNM
	JP	P,EPRVL3
FCER:	LD	E,8		; FC-ERROR
	JP	ERROO
	;
EPRVL4:	CALL	SNALY2
EPRVL3:	LD	A,(WRA1+3)
	CP	90H
	JP	C,INTMOV
	LD	BC,9080H
	LD	DE,0000H
	PUSH	HL
	CALL	VORZ1
	POP	HL
	LD	D,C
	RET	Z
	JR	FCER
 
;UMWANDLUNG EINGEGEBENER ZAHLEN IM ASCII-CODE
;IN HEXADEZIMALZAHLEN
; PE:	HL	Eingabepuffer, wo Dezimalzahl beginnt
; PA:	DE	erfasste Zahl in hexadezimal
DCHEX:	DEC	HL
DCHEX1:	LD	DE,0	; Startwert
DCHEX2:	CALL	TCHAR	; naechstes Zeichen
	RET	NC	; fertig
	PUSH	HL
	PUSH	AF
	LD	HL,6552
	CALL	CPREG
	JP	C,SNER
	LD	H,D
	LD	L,E
	ADD	HL,DE	; *2
	ADD	HL,HL	; *4
	ADD	HL,DE	; *5
	ADD	HL,HL	; *10
	POP	AF
	SUB	'0'
	LD	E,A
	LD	D,0
	ADD	HL,DE	; aktuelle Ziffer addieren
	EX	DE,HL	; Wert in DE
	POP	HL	; Eingabepuffer
	JR	DCHEX2	; naechstes Zeichen
;
CLEAR:	JR	Z,CLEAR2
	CALL	EPRVL1
	CALL	TCHAR1
	PUSH	HL
	LD	HL,(MEMSIZ)
	JR	Z,CLEAR1
	POP	HL
	CALL	CPCOMM
	PUSH	DE
	CALL	EPRVL4
	CALL	TCHAR1
	JP	NZ,SNER
	EX	(SP),HL
	EX	DE,HL
CLEAR1:	LD	A,L
	SUB	E
	LD	E,A
	LD	A,H
	SBC	A,D
	LD	D,A
	JP	C,OMER		; -> OM ERROR
	PUSH	HL
	LD	HL,(SVARPT)
	LD	BC,40
	ADD	HL,BC
	CALL	CPREG
	JP	NC,OMER		; -> OM ERROR
	EX	DE,HL
	LD	(STDPTR),HL
	POP	HL
	LD	(MEMSIZ),HL
	POP	HL
CLEAR2:	JP	NEW3
;
;PROGRAMMSTART, UP-TECHNIK,DATA UND REMARKS
RUN:	JP	Z,NEW2
	CALL	NEW3
	LD	BC,RUNMOD
	JR	GOTO0
 
GOSUB:	LD	C,3
	CALL	TMEMO
	POP	BC
	PUSH	HL
	PUSH	HL
	LD	HL,(CULINO)	; aktuelle Zeilennummer
	EX	(SP),HL
	LD	A,GSBTOK
	PUSH	AF
	INC	SP
GOTO0:	PUSH	BC
GOTO:	CALL	DCHEX		; Dezimalzahl erfassen
	CALL	REM
	PUSH	HL
	LD	HL,(CULINO)	; aktuelle Zeilennummer
	CALL	CPREG
	POP	HL
	INC	HL
	CALL	C,ZPOIT1
	CALL	NC,ZPOIT
	LD	H,B
	LD	L,C
	DEC	HL
	RET	C
ULER:	LD	E,14		; UL-ERROR
ULER1:	JP	ERROO
 
RETUR:	RET	NZ
	LD	D,0FFH
	CALL	FORSR
	LD	SP,HL
	CP	GSBTOK
RGER:	LD	E,4		; RG-ERROR
	JR	NZ,ULER1
	POP	HL
	LD	(CULINO),HL	; aktuelle Zeilennummer
	INC	HL
	LD	A,H
	OR	L
	JR	NZ,RETUR1
	LD	A,(IPHFLG)
	OR	A
	JP	NZ,EDIT0
RETUR1:	LD	HL,RUNMOD
	EX	(SP),HL
	DEFB	3EH		; LD A,0E1H
DATA0:	POP	HL
DATA:	DEFW	3A01H		; LD BC,0E3AH
ELSE:				; NOP
REM:	LD	C,0
	LD	B,0
REM1:	LD	A,C
	LD	C,B
	LD	B,A
REM2:	LD	A,(HL)
	OR	A
	RET	Z
	CP	B
	RET	Z
	INC	HL
	CP	'"'
	JR	Z,REM1
	JR	REM2
;
;WERTZUWEISUNG
LET:	CALL	DIM1
	CALL	CPSTX
	DEFB	EQUTOK
	PUSH	DE
	LD	A,(DATYPE)
	PUSH	AF
	CALL	SNALY
	POP	AF
	EX	(SP),HL
	LD	(CUSTMT),HL	; ZEILENNUMMER/ADRESSE DES AKTUELLEN STATEMENTS
	RRA
	CALL	SNALY5
	JR	Z,LET4
LET1:	PUSH	HL
	LD	HL,(WRA1)
	PUSH	HL
	INC	HL
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	COND	ZFT
	LD	HL,(MEMSIZ)
	CALL	CPREG
	JR	C,LET2
	ENDC
	COND	ZFT-1
	LD	HL,(PSTBEG)	; Programmstart-Adresse
	CALL	CPREG
	JR	NC,LET2
	ENDC
	LD	HL,(STDPTR)
	CALL	CPREG
	POP	DE
	JR	NC,LET3
	LD	HL,EOLSPT+1
	CALL	CPREG
	JR	NC,LET3
	DEFB	3EH
LET2:	POP	DE
	CALL	SPTSRH
	EX	DE,HL
	CALL	STR_1
LET3:	CALL	SPTSRH
	POP	HL
	CALL	OPTRN1
	POP	HL
	RET
	;
LET4:	PUSH	HL
	CALL	OPTRAN
	POP	DE
	POP	HL
	RET
;
;PROGRAMMVERZWEIGUNGEN
ON:	CALL	ARGVL1
	LD	A,(HL)
	LD	B,A
	CP	GSBTOK
	JR	Z,ON1
	CALL	CPSTX
	DEFB	GTOTOK
	DEC	HL
ON1:	LD	C,E
ON2:	DEC	C
	LD	A,B
	JP	Z,DCLI2
	CALL	DCHEX1
	CP	','
	RET	NZ
	JR	ON2
 
IF:	CALL	SNALY
	LD	A,(HL)
	CP	GTOTOK
	JR	Z,IF1
	CALL	CPSTX
	DEFB	THNTOK
	DEC	HL
IF1:	CALL	SNALY3
	CALL	TSGNM
	JR	NZ,IF3
IF2:	INC	HL
	LD	A,(HL)
	OR	A
	RET	Z
	CP	ELSTOK
	JR	NZ,IF2
IF3:	CALL	TCHAR
	JP	C,GOTO
	JP	RUNMD3
;
;AUSDRUCK VON WERTEN UND STRINGS UND FORMATSTEUERUNG
PRINT0:	CALL	TCHAR1
	JR	PRINT1
	;
PRINT:	XOR	A
	LD	(PRTFLG),A	 ;noch keine PRINT-Erweiterung
	CALL	OUTCHL
PRINT1:	JR	Z,CRWDY2
PRINT2:	RET	Z
	CP	LAST+1
	JR	C,PRINT6	; Token fuer Erweiterung
	LD	A,(EXTFLG)	; nicht in Grundliste
	AND	A		; Erweiterung vorhanden?
	JR	Z,PRINT6
	CALL	EXTGO2
PRINT6:	CP	TABTOK		; Fehler
	JP	Z,TAB
	CP	SPCTOK
	JR	Z,TAB
	PUSH	HL
	CP	','
	JR	Z,FORMAT
	CP	';'
	JP	Z,TAB4
	POP	BC
	CALL	SNALY
	PUSH	HL
	LD	A,(DATYPE)
	OR	A
	JR	NZ,PRINT4
	CALL	NUMKON
	CALL	SLEN0
	LD	(HL),' '
	LD	HL,(WRA1)
	INC	(HL)
	LD	HL,(WRA1)
	LD	A,(LINLEN)
	LD	B,A
	INC	B
	JR	Z,PRINT3
	INC	B
	LD	A,(CURPOS)
	ADD	A,(HL)
	DEC	A
	CP	B
	CALL	NC,CRWDY2
PRINT3:
PRINT4:	CALL	TEXTO1
	POP	HL
PRINT5:	JR	PRINT0
 
;AUSGABE EINES LF- UND EINES CR(ASCII)ZEICHENS
;AM ZEILENENDE,ZUSAETZLICH AUSGABE DER VEREIN-
;BARTEN ANZAHL VON DUMMYZEICHEN
CRWDY:	LD	A,(CURPOS)
	OR	A
	RET	Z		; bereits auf Zeilenanfang
	JR	CRWDY2
	;
CRWDY1:	LD	(HL),0
CRWDY6:	LD	HL,INPBUF
CRWDY2:	LD	A,0DH		; CR
	CALL	CHARO
CRWDY5:	LD	A,0AH		; LF
	CALL	CHARO
CRWDY3:	XOR	A
	LD	(CURPOS),A
	LD	A,(DUMMY)	; Anzahl Dummy-Zeichen
CRWDY4:	DEC	A
	RET	Z		; fertig
	PUSH	AF
	XOR	A		; Dummy-Zeichen
	CALL	CHARO		; anzeigen
	POP	AF
	JR	CRWDY4
 
;ORGANISATION DER AUSGABEFORMATIERUNG BEI
;MEHREREN LISTENELEMENTEN IN DER PRINT-ANWEISUNG
FORMAT:	LD	A,(PRLISI)
	LD	B,A
	LD	A,(CURPOS)
	CP	B
	CALL	NC,CRWDY2
	JR	NC,TAB4
FORM1:	SUB	13
	JR	C,FORM2
	JR	NZ,FORM1
FORM2:	CPL
	JR	TAB2
;ORGANISATION DES TABULATORSPRUNGES
TAB:	PUSH	AF
	CALL	ARGVAL
	CALL	CPBRGT
	DEC	HL
	POP	AF
	SUB	SPCTOK
	PUSH	HL
	JR	Z,TAB1
	LD	A,(CURPOS)
TAB1:	CPL
	ADD	A,E
	JR	NC,TAB4
TAB2:	INC	A
	JR	Z,TAB4
	LD	B,A
	LD	A,' '
TAB3:	CALL	CHARO
	DJNZ	TAB3
TAB4:	POP	HL
	CALL	TCHAR
	JP	PRINT2
 
WIDTH:	CALL	ARGVL1
	LD	(LINLEN),A
	RET

NULL:	CALL	ARGVL1
	RET	NZ
	INC	A
	LD	(DUMMY),A		; neue Anzahl Dummy-Zeichen
	RET
;
;EINGABE VON WERTEN (EXT. ODER INT.)
RED:	DEFM	'?REDO FROM START'
	DEFW	ASCCR
REDOUT:	LD	A,(RDFLAG)
	OR	A
	JP	NZ,SNER0
	POP	BC
	LD	HL,RED
	CALL	TEXTO
	JP	INITR2
 
INPUT:	CALL	DMODTS
	CALL	INCHNL
	XOR	A
	LD	(OUTFLG),A	; Ausgabe nicht unterdruecken
	LD	A,(HL)
	CP	'"'
	JR	NZ,INPUT1
	CALL	SOPRND
	CALL	CPSTX
	DEFB	';'
	PUSH	HL
	CALL	TEXTO1
	CALL	OUT1?
	JR	INPUT2
	;
INPUT1:	PUSH	HL
;EINGABEANFORDERUNG
	CALL	OUT?
INPUT2:	POP	BC
	JR	C,READ14
	LD	HL,INPBUF+1
	LD	A,(HL)
	OR	A
	DEC	HL
	PUSH	BC
	JR	Z,READ13
	LD	(HL),','
	JR	READ1
 
READ:	PUSH	HL
	LD	HL,(RDPTR)
	DEFB	0F6H
READ1:	XOR	A
	LD	(RDFLAG),A
	EX	(SP),HL
	JR	READ3
	;
READ2:	CALL	CPCOMM
READ3:	CALL	DIM1
	EX	(SP),HL
	PUSH	DE
	LD	A,(HL)
	CP	','
	JR	Z,READ4
	LD	A,(RDFLAG)
	OR	A
	JR	NZ,READ10
;WIEDERHOLTE EINGABEANFORDERUNG
	LD	A,'?'
	CALL	CHARO
	CALL	OUT?
	POP	DE
	POP	BC
READ14:	JP	C,END1
	LD	HL,INPBUF+1
	LD	A,(HL)
	OR	A
	DEC	HL
	PUSH	BC
READ13:	JP	Z,DATA0
	PUSH	DE
READ4:	LD	A,(DATYPE)
	OR	A
	JR	Z,READ7
	CALL	TCHAR
	LD	D,A
	LD	B,A
	CP	'"'
	JR	Z,READ6
	LD	A,(RDFLAG)
	OR	A
	LD	D,A
	JR	Z,READ5
	LD	D,':'
READ5:	LD	B,','
	DEC	HL
READ6:	CALL	STRLEN
	EX	DE,HL
	LD	HL,READ8
	EX	(SP),HL
	PUSH	DE
	JP	LET1
READ7:	CALL	TCHAR
	CALL	VALNRM
	EX	(SP),HL
	CALL	OPTRAN
	POP	HL
READ8:	CALL	TCHAR1
	JR	Z,READ9
	CP	','
	JP	NZ,REDOUT
READ9:	EX	(SP),HL
	CALL	TCHAR1
	JR	NZ,READ2
	POP	DE
	LD	A,(RDFLAG)
	OR	A
	EX	DE,HL
	JP	NZ,RESTO2
	PUSH	DE
	OR	(HL)
	LD	HL,EXTR
	CALL	NZ,TEXTO
	POP	HL
	RET
	;
EXTR:	DEFM	'?EXTRA IGNORED'
	DEFW	ASCCR
READ10:	CALL	DATA
	OR	A
	JR	NZ,READ11
	INC	HL
	LD	A,(HL)
	INC	HL
	OR	(HL)
ODER:	LD	E,6		; OD-ERROR
	JP	Z,ERROO
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	(DATPTR),DE
READ11:	CALL	TCHAR
	CP	DATTOK
	JR	NZ,READ10
READ12:	JP	READ4
;
;VORRANGSTEUERUNG DR OPERATOREN UND SCHLEIFENABSCHLUSS
;ENDE DER MIT  F O R  EROEFFNETEN SCHLEIFE
NEXT:	LD	DE,0
NEXT1:	CALL	NZ,DIM1
	LD	(CUSTMT),HL	; ZEILENNUMMER/ADRESSE DES AKTUELLEN STATEMENTS
	CALL	FORSR
	JP	NZ,NFER
	LD	SP,HL
	PUSH	DE
	LD	A,(HL)
	INC	HL
	PUSH	AF
	PUSH	DE
	CALL	OPKOP
	EX	(SP),HL
	PUSH	HL
	CALL	ADD2
	POP	HL
	CALL	OPTRAN
	POP	HL
	CALL	OPLAD
	PUSH	HL
	CALL	VORZ1
	POP	HL
	POP	BC
	SUB	B
	CALL	OPLAD
	JR	Z,NEXT2
	LD	(CULINO),DE	; aktuelle Zeilennummer
	LD	L,C
	LD	H,B
	JP	FOR4
;ROUTINE ZUR AUFSTELLUNG EINES RPN-VEKTORS IM
;STACK, UM VERKETTETE AUFGABEN ZU LOESENN
NEXT2:	LD	SP,HL
	LD	HL,(CUSTMT)	; ZEILENNUMMER/ADRESSE DES AKTUELLEN STATEMENTS
	LD	A,(HL)
	CP	','
	JP	NZ,RUNMOD
	CALL	TCHAR
	CALL	NEXT1
SNALY2:	CALL	SNALY
SNALY3:	DEFB	0F6H		; OR n setzt CY=0
SNALY4:	SCF
SNALY5:	LD	A,(DATYPE)
	ADC	A,A
	OR	A
	RET	PE
TMER:	LD	E,24		; TM-ERROR
	JP	ERROO

SNALY6:	CALL	CPSTX
	DEFB	'('
SNALY:	DEC	HL
	LD	D,0
SNALY7:	PUSH	DE
	LD	C,1
	CALL	TMEMO
	CALL	SNLY13
SNALY8:	LD	(NTOKPT),HL
SNALY9:	LD	HL,(NTOKPT)
	POP	BC
	LD	A,B
	CP	78H
	CALL	NC,SNALY3
	LD	A,(HL)
	LD	D,0
SNLY10:	SUB	GRTTOK
	JR	C,SNLY11
	CP	LTHTOK-GRTTOK+1
	JR	NC,SNLY11
	CP	EQUTOK-GRTTOK
	RLA
	XOR	D
	CP	D
	LD	D,A
	JP	C,SNER
	LD	(LBYTEX),HL
	CALL	TCHAR
	JR	SNLY10
	;
SNLY11:	LD	A,D
	OR	A
	JP	NZ,SNLY24
	LD	A,(HL)
	LD	(LBYTEX),HL
	SUB	PLUTOK
	RET	C
	CP	GRTTOK-PLUTOK
	RET	NC
	LD	E,A
	LD	A,(DATYPE)
	DEC	A
	OR	E
	LD	A,E
	JP	Z,STRSNA
	RLCA
	ADD	A,E
	LD	E,A
	LD	HL,ADRTB3
	ADD	HL,DE
	LD	A,B
	LD	D,(HL)
	CP	D
	RET	NC
	INC	HL
	CALL	SNALY3
SNLY12:	PUSH	BC
	LD	BC,SNALY9
	PUSH	BC
	LD	B,E
	LD	C,D
	CALL	OPARST
	LD	E,B
	LD	D,C
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	INC	HL
	PUSH	BC
	LD	HL,(LBYTEX)
	JR	SNALY7
	;
SNLY13:	XOR	A
	LD	(DATYPE),A
	CALL	TCHAR
;AUSGABE EINES FEHLERS BEI UNVOLLSTAENDIGEM
;VERKETTETEN AUSDRUCK
MOER:	LD	E,36		; MO-ERROR
	JP	Z,ERROO
	JP	C,VALNRM
	CALL	CLETST
	JR	NC,SNLY17
	CP	PLUTOK
	JR	Z,SNLY13
	CP	'.'
	JP	Z,VALNRM
	CP	MINTOK
	JR	Z,SNLY15
	CP	'"'
	JP	Z,SOPRND
	CP	NOTTOK
	JP	Z,NOT
	CP	FNTOK
	JP	Z,FN
	SUB	SGNTOK
	JR	NC,SNLY19
SNLY14:	CALL	SNALY6
	JP	CPBRGT
SNLY15:	LD	D,7DH
	CALL	SNALY7
	LD	HL,(NTOKPT)
	PUSH	HL
	CALL	ABS1
SNLY16:	CALL	SNALY3
	POP	HL
	RET
	;
SNLY17:	CALL	DIM1
SNLY18:	PUSH	HL
	EX	DE,HL
	LD	(WRA1),HL
	LD	A,(DATYPE)
	OR	A
	CALL	Z,OPKOP
	POP	HL
	RET
	;
SNLY19:	LD	B,0
	RLCA
	LD	C,A
	PUSH	BC
	CALL	TCHAR
	LD	A,C
	CP	1+MIDTOK-SGNTOK+MIDTOK-SGNTOK
	JR	C,SNLY29
	LD	A,(EXTFLG)
	AND	A
	JP	NZ,EXTGO3	;TOKEN NICHT IN GRUNDLISTE
SNLY29:	CP	PITOK-SGNTOK+PITOK-SGNTOK
	JR	Z,SNLY2A
	CP	1+CHRTOK-SGNTOK+CHRTOK-SGNTOK
	JR	C,SNLY20
	CALL	SNALY6
	CALL	CPCOMM
	CALL	SNALY4
	EX	DE,HL
	LD	HL,(WRA1)
	EX	(SP),HL
	PUSH	HL
	EX	DE,HL
	CALL	ARGVL1
	EX	DE,HL
	EX	(SP),HL
	JR	SNLY21
	;
SNLY20:	CALL	SNLY14
SNLY2A:	EX	(SP),HL
	LD	DE,SNLY16
	PUSH	DE
SNLY21:	LD	BC,ADRTB2
	ADD	HL,BC
	LD	C,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,C
	JP	(HL)
SNLY22:	DEC	D
	CP	MINTOK
	RET	Z
	CP	'-'
	RET	Z
	INC	D
	CP	'+'
	RET	Z
	CP	PLUTOK
	RET	Z
	DEC	HL
	RET
;
;LOGISCHE OPERATOREN - BITWEISE
OR:	DEFB	0F6H
AND:	XOR	A
	PUSH	AF
	CALL	SNALY3
	CALL	EPRVL3
	POP	AF
	EX	DE,HL
	POP	BC
	EX	(SP),HL
	EX	DE,HL
	CALL	OPKOP1
	PUSH	AF
	CALL	EPRVL3
	POP	AF
	POP	BC
	LD	A,C
	LD	HL,FRE2
	JR	NZ,SNLY23
	AND	E
	LD	C,A
	LD	A,B
	AND	D
	JP	(HL)
SNLY23:	OR	E
	LD	C,A
	LD	A,B
	OR	D
	JP	(HL)
 
SNLY24:	LD	HL,SNLY25
	LD	A,(DATYPE)
	RRA
	LD	A,D
	RLA
	LD	E,A
	LD	D,100
	LD	A,B
	CP	D
	RET	NC
	JP	SNLY12
 
SNLY25:	DEFW	SNLY26
SNLY26:	LD	A,C
	OR	A
	RRA
	POP	BC
	POP	DE
	PUSH	AF
	CALL	SNALY5
	LD	HL,SNLY28
	PUSH	HL
	JP	Z,VORZ1
	XOR	A
	LD	(DATYPE),A
	PUSH	DE
	CALL	STRZS1
	LD	A,(HL)
	INC	HL
	INC	HL
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	POP	DE
	PUSH	BC
	PUSH	AF
	CALL	STRZS3
	CALL	OPLAD
	POP	AF
	LD	D,A
	POP	HL
SNLY27:	LD	A,E
	OR	D
	RET	Z
	LD	A,D
	SUB	1
	RET	C
	XOR	A
	CP	E
	INC	A
	RET	NC
	DEC	D
	DEC	E
	LD	A,(BC)
	CP	(HL)
	INC	HL
	INC	BC
	JR	Z,SNLY27
	CCF
	JP	TSGNM2
 
SNLY28:	INC	A
	ADC	A,A
	POP	BC
	AND	B
	ADD	A,-1
	SBC	A,A
	JP	SGN0
 
NOT:	LD	D,5AH
	CALL	SNALY7
	CALL	SNALY3
	CALL	EPRVL3
	LD	A,E
	CPL
	LD	C,A
	LD	A,D
	CPL
	CALL	FRE2
	POP	BC
	JP	SNALY9
;
;DATENFELDAUFBAU UND -VEERWALTUNG
DIM0:	CALL	TCHAR1
	RET	Z
	CALL	CPCOMM
DIM:	LD	BC,DIM0
	PUSH	BC
	DEFB	0F6H
DIM1:	XOR	A
	LD	(LOCCRE),A
	LD	B,(HL)
DIM2:	CALL	CLETST
	JP	C,SNER
	XOR	A
	LD	C,A
	LD	(DATYPE),A
	CALL	TCHAR
	JR	C,DIM3
	CALL	CLETST
	JR	C,DIM5
DIM3:	LD	C,A
DIM4:	CALL	TCHAR
	JR	C,DIM4
	CALL	CLETST
	JR	NC,DIM4
DIM5:	SUB	'$'
	JR	NZ,DIM6
	INC	A
	LD	(DATYPE),A
	RRCA
	ADD	A,C
	LD	C,A
	CALL	TCHAR
DIM6:	LD	A,(FORFLG)
	DEC	A
	JP	Z,DIM16
	JP	P,DIM7
	LD	A,(HL)
	SUB	'('
	JR	Z,DIM14
DIM7:	XOR	A
	LD	(FORFLG),A
	PUSH	HL
	LD	D,B
	LD	E,C
	LD	HL,(FNPTR)
	CALL	CPREG
	LD	DE,WRA0
	JP	Z,MUL5
	LD	HL,(DVARPT)
	EX	DE,HL
	LD	HL,(SVARPT)
DIM8:	CALL	CPREG
	JR	Z,DIM10
	LD	A,C
	SUB	(HL)
	INC	HL
	JR	NZ,DIM9
	LD	A,B
	SUB	(HL)
DIM9:	INC	HL
	JR	Z,DIM12
	INC	HL
	INC	HL
	INC	HL
	INC	HL
	JR	DIM8
	;
DIM10:	POP	HL
	EX	(SP),HL
	PUSH	DE
	LD	DE,SNLY18
	CALL	CPREG
	POP	DE
	JR	Z,DIM13
	EX	(SP),HL
	PUSH	HL
	PUSH	BC
	LD	BC,6
	LD	HL,(FSLPTR)
	PUSH	HL
	ADD	HL,BC
	POP	BC
	PUSH	HL
	CALL	LININ
	POP	HL
	LD	(FSLPTR),HL
	LD	H,B
	LD	L,C
	LD	(DVARPT),HL
DIM11:	DEC	HL
	LD	(HL),0
	CALL	CPREG
	JR	NZ,DIM11
	POP	DE
	LD	(HL),E
	INC	HL
	LD	(HL),D
	INC	HL
DIM12:	EX	DE,HL
DIM121:	POP	HL
	RET
	;
DIM13:	LD	(WRA1+3),A
	LD	HL,OK+3
	LD	(WRA1),HL
	POP	HL
	RET
	;
DIM14:	PUSH	HL
	LD	HL,(LOCCRE)
	EX	(SP),HL
	LD	D,A
DIM15:	PUSH	DE
	PUSH	BC
	CALL	EPRVAL
	POP	BC
	POP	AF
	EX	DE,HL
	EX	(SP),HL
	PUSH	HL
	EX	DE,HL
	INC	A
	LD	D,A
	LD	A,(HL)
	CP	','
	JR	Z,DIM15
	CALL	CPBRGT
	LD	(NTOKPT),HL
	POP	HL
	LD	(LOCCRE),HL
	LD	E,0
	PUSH	DE
	DEFB	11H
DIM16:	PUSH	HL
	PUSH	AF
	LD	HL,(DVARPT)
	DEFB	3EH
DIM17:	ADD	HL,DE
	LD	DE,(FSLPTR)
	CALL	CPREG
	JR	Z,DIM19
	LD	A,(HL)
	CP	C
	INC	HL
	JR	NZ,DIM18
	LD	A,(HL)
	CP	B
DIM18:	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	INC	HL
	JR	NZ,DIM17
	LD	A,(LOCCRE)
	OR	A
	JP	NZ,DDER
	POP	AF
	LD	B,H
	LD	C,L
	JP	Z,DIM121
	SUB	(HL)
	JR	Z,DIM23
BSER:	LD	E,16		; BS-ERROR
	JP	ERROO
	;
DIM19:	LD	DE,4
	POP	AF
	JP	Z,FCER
	LD	(HL),C
	INC	HL
	LD	(HL),B
	INC	HL
	LD	C,A
	CALL	TMEMO
	INC	HL
	INC	HL
	LD	(LBYTEX),HL
	LD	(HL),C
	INC	HL
	LD	A,(LOCCRE)
	RLA
	LD	A,C
DIM20:	LD	BC,11
	JR	NC,DIM21
	POP	BC
	INC	BC
DIM21:	LD	(HL),C
	INC	HL
	LD	(HL),B
	INC	HL
	PUSH	AF
	PUSH	HL
	CALL	FESRCH
	EX	DE,HL
	POP	HL
	POP	AF
	DEC	A
	JR	NZ,DIM20
	PUSH	AF
	LD	B,D
	LD	C,E
	EX	DE,HL
	ADD	HL,DE
	JP	C,OMER		; -> OM ERROR
	CALL	TMEMO1
	LD	(FSLPTR),HL
DIM22:	DEC	HL
	LD	(HL),0
	CALL	CPREG
	JR	NZ,DIM22
	INC	BC
	LD	D,A
	LD	HL,(LBYTEX)
	LD	E,(HL)
	EX	DE,HL
	ADD	HL,HL
	ADD	HL,BC
	EX	DE,HL
	DEC	HL
	DEC	HL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	INC	HL
	POP	AF
	JR	C,DIM25
DIM23:	LD	B,A
	LD	C,A
	LD	A,(HL)
	INC	HL
	DEFB	16H
DIM24:	POP	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	INC	HL
	EX	(SP),HL
	PUSH	AF
	CALL	CPREG
	JR	NC,BSER
	PUSH	HL
	CALL	FESRCH
	POP	DE
	ADD	HL,DE
	POP	AF
	DEC	A
	LD	B,H
	LD	C,L
	JR	NZ,DIM24
	ADD	HL,HL
	ADD	HL,HL
	POP	BC
	ADD	HL,BC
	EX	DE,HL
DIM25:	LD	HL,(NTOKPT)
	RET
;
FRE:	LD	DE,(FSLPTR)
	LD	HL,0
	ADD	HL,SP
	LD	A,(DATYPE)
	OR	A
	JR	Z,FRE1
	CALL	STRZS1
	CALL	STROP4
	LD	DE,(STDPTR)
	LD	HL,(SWAPTR)
FRE1:	LD	A,L
	SUB	E
	LD	C,A
	LD	A,H
	SBC	A,D
FRE2:	LD	B,C
FRE3:	LD	D,B
	LD	E,0
	LD	HL,DATYPE
	LD	(HL),E
	LD	B,90H
	JP	SGN1
 
POS:	LD	A,(CURPOS)
POS1:	LD	B,A
	XOR	A
	JR	FRE3
;
;BENUTZERDEFINIERTE FUNKTIONEN (BILDUNG UND AUFRUF)
DEF:	CALL	FNSRCH
	CALL	DMODTS
	LD	BC,DATA
	PUSH	BC
	PUSH	DE
	CALL	CPSTX
	DEFB	'('
	CALL	DIM1
	PUSH	HL
	EX	DE,HL
	DEC	HL
	LD	D,(HL)
	DEC	HL
	LD	E,(HL)
	POP	HL
	CALL	SNALY3
	CALL	CPBRGT
	CALL	CPSTX
	DEFB	EQUTOK
	LD	B,H
	LD	C,L
	EX	(SP),HL
	LD	(HL),C
	INC	HL
	LD	(HL),B
	JP	SADTB2
 
FN:	CALL	FNSRCH
	PUSH	DE
	CALL	SNLY14
	CALL	SNALY3
	EX	(SP),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	INC	HL
	LD	A,D
	OR	E
	JP	Z,UFER
	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A
	PUSH	HL
	LD	HL,(FNPTR)
	EX	(SP),HL
	LD	(FNPTR),HL
	LD	HL,(WRA0+2)
	PUSH	HL
	LD	HL,(WRA0)
	PUSH	HL
	LD	HL,WRA0
	PUSH	DE
	CALL	OPTRAN
	POP	HL
	CALL	SNALY2
	CALL	TCHAR1
	JP	NZ,SNER
	POP	HL
	LD	(WRA0),HL
	POP	HL
	LD	(WRA0+2),HL
	POP	HL
	LD	(FNPTR),HL
	POP	HL
	RET
;
;TEST, OB PROGRAMMABARBEITUNG IM DIREKTMODE
DMODTS:	PUSH	HL
	LD	HL,(CULINO)	; aktuelle Zeilennummer
	INC	HL
	LD	A,H
	OR	L
	POP	HL
	RET	NZ
IDER:	LD	E,22		; ID-ERROR
	JP	ERROO
 
FNSRCH:	CALL	CPSTX
	DEFB	FNTOK
	LD	A,80H
	LD	(FORFLG),A
	OR	(HL)
	LD	B,A
	CALL	DIM2
	JP	SNALY3
;
;STRINGBEHANDLUNG
STR_:	CALL	SNALY3
	CALL	NUMKON
	CALL	SLEN0
	CALL	STRZS1
	LD	BC,CHR_1
	PUSH	BC
STR_1:	LD	A,(HL)
	INC	HL
	INC	HL
	PUSH	HL
	CALL	STROP
	POP	HL
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	CALL	SADTB1
	PUSH	HL
	LD	L,A
	CALL	STRMV1
	POP	DE
	RET

STADTB:	CALL	STROP
SADTB1:	LD	HL,STRDAT
	PUSH	HL
	LD	(HL),A		; Laenge
	INC	HL
SADTB2:	INC	HL
	LD	(HL),E		; Adresse der Zeichenkette
	INC	HL
	LD	(HL),D
	POP	HL
	RET

; Laenge einer Zeichenkette ermitteln
; PE:	HL	Zeiger auf Zeichenkette
; PA:	BC	Laenge der Zeichenkette
SLEN0:	DEC	HL
SOPRND:	LD	B,'"'
	LD	D,B
STRLEN:	PUSH	HL
	LD	C,-1		; Zaehler Startwert
SLEN1:	INC	HL
	LD	A,(HL)
	INC	C
	OR	A
	JR	Z,SLEN2		; Ende mit 00
	CP	D
	JR	Z,SLEN2
	CP	B
	JR	NZ,SLEN1	; naechstes Zeichen testen
SLEN2:	CP	'"'
	CALL	Z,TCHAR
	EX	(SP),HL
	INC	HL		; Stringanfang jetzt wieder in HL
	EX	DE,HL
	LD	A,C		; Stringlaenge
	CALL	SADTB1		; Adresse und Laenge aktueller String eintragen
SLEN3:	LD	DE,STRDAT
	LD	HL,(SPTPTR)
	LD	(WRA1),HL
	LD	A,1
	LD	(DATYPE),A
	CALL	OPTRN1
	CALL	CPREG
	LD	(SPTPTR),HL
	POP	HL
	LD	A,(HL)
	RET	NZ
STER:	LD	E,30		; ST-ERROR
STER1:	JP	ERROO
;
TEXTO0:	INC	HL
;AUSGABE EINER MIT 00 ENDENDEN ASCII-ZEICHENKETTE
;AUS DEM SPEICHER, ANFANGSADRESSE IM REGISTER HL
TEXTO:	CALL	SLEN0		; String-Laenge ermitteln
TEXTO1:	CALL	STRZS1
	CALL	OPLAD		; Laenge in Register E / Zeichenkette in BC
	INC	E
TEXTO2:	DEC	E		; fertig?
	RET	Z		; ja.
	LD	A,(BC)		; Zeichen aus Zeichenkette
TEXTO3:	CALL	CHARO
	CP	0DH		; CR?
	CALL	Z,CRWDY5	; ja, dann LF anhaengen
	INC	BC		; naechste Position in Zeichenkette
	JR	TEXTO2

;
;STRINGARITHMETIK
STROP:	OR	A
	DEFB	0EH
STROP1:	POP	AF
	PUSH	AF
	LD	DE,(STDPTR)
	LD	HL,(SWAPTR)
	CPL
	LD	C,A
	LD	B,-1
	ADD	HL,BC
	INC	HL
	CALL	CPREG
	JR	C,STROP3
	LD	(SWAPTR),HL
	INC	HL
	EX	DE,HL
STROP2:	POP	AF
	RET

STROP3:	POP	AF
OSER:	LD	E,26
	JR	Z,STER1
	CP	A
	PUSH	AF
	LD	BC,STROP1
	PUSH	BC
STROP4:	LD	HL,(MEMSIZ)
STROP5:	LD	(SWAPTR),HL
	LD	HL,0
	PUSH	HL
	LD	HL,(STDPTR)
	PUSH	HL
	LD	HL,LSPTBG
STROP6:	LD	DE,(SPTPTR)
	CALL	CPREG
	LD	BC,STROP6
	JR	NZ,STRO11
	LD	HL,(SVARPT)
STROP7:	LD	DE,(DVARPT)
	CALL	CPREG
	JR	Z,STROP9
	LD	A,(HL)
	INC	HL
	INC	HL
	OR	A
	CALL	STRO12
	JR	STROP7
 
STROP8:	POP	BC
STROP9:	LD	DE,(FSLPTR)
	CALL	CPREG
	JR	Z,STRO13
	CALL	OPLAD
	LD	A,E
	PUSH	HL
	ADD	HL,BC
	OR	A
	JP	P,STROP8
	LD	(LBYTEX),HL
	POP	HL
	LD	C,(HL)
	LD	B,0
	ADD	HL,BC
	ADD	HL,BC
	INC	HL
STRO10:	LD	DE,(LBYTEX)
	CALL	CPREG
	JR	Z,STROP9
	LD	BC,STRO10
STRO11:	PUSH	BC
	OR	80H
STRO12:	LD	A,(HL)
	INC	HL
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	INC	HL
	RET	P
	OR	A
	RET	Z
	LD	B,H
	LD	C,L
	LD	HL,(SWAPTR)
	CALL	CPREG
	LD	H,B
	LD	L,C
	RET	C
	POP	HL
	EX	(SP),HL
	CALL	CPREG
	EX	(SP),HL
	PUSH	HL
	LD	H,B
	LD	L,C
	RET	NC
	POP	BC
	POP	AF
	POP	AF
	PUSH	HL
	PUSH	DE
	PUSH	BC
	RET

STRO13:	POP	DE
	POP	HL
	LD	A,L
	OR	H
	RET	Z
	DEC	HL
	LD	B,(HL)
	DEC	HL
	LD	C,(HL)
	PUSH	HL
	DEC	HL
	DEC	HL
	LD	L,(HL)
	LD	H,0
	ADD	HL,BC
	LD	D,B
	LD	E,C
	DEC	HL
	LD	B,H
	LD	C,L
	LD	HL,(SWAPTR)
	CALL	LININ1
	POP	HL
	LD	(HL),C
	INC	HL
	LD	(HL),B
	LD	L,C
	LD	H,B
	DEC	HL
	JP	STROP5
 
STRSNA:	PUSH	BC
	PUSH	HL
	LD	HL,(WRA1)
	EX	(SP),HL
	CALL	SNLY13
	EX	(SP),HL
	CALL	SNALY4
	LD	A,(HL)
	PUSH	HL
	LD	HL,(WRA1)
	PUSH	HL
	ADD	A,(HL)
LSER:	LD	E,28		; LS-ERROR
	JP	C,ERROO
	CALL	STADTB
	POP	DE
	CALL	STRZS3
	EX	(SP),HL
	CALL	STRZS2
	PUSH	HL
	LD	HL,(STRDAT+2)
	EX	DE,HL
	CALL	STRMOV
	CALL	STRMOV
	LD	HL,SNALY8
	EX	(SP),HL
	PUSH	HL
	JR	CHR_2
 
STRMOV:	POP	HL
	EX	(SP),HL
	LD	A,(HL)
	INC	HL
	INC	HL
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	LD	L,A
STRMV1:	INC	L
STRMV2:	DEC	L
	RET	Z
	LD	A,(BC)
	LD	(DE),A
	INC	BC
	INC	DE
	JR	STRMV2
 
STRZSP:	CALL	SNALY4
STRZS1:	LD	HL,(WRA1)
STRZS2:	EX	DE,HL
STRZS3:	CALL	SPTSRH
	EX	DE,HL
	RET	NZ
	PUSH	DE
	LD	D,B
	LD	E,C
	DEC	DE
	LD	C,(HL)
	LD	HL,(SWAPTR)
	CALL	CPREG
	JR	NZ,STRZS4
	LD	B,A
	ADD	HL,BC
	LD	(SWAPTR),HL
STRZS4:	POP	HL
	RET

SPTSRH:	LD	HL,(SPTPTR)
	DEC	HL
	LD	B,(HL)
	DEC	HL
	LD	C,(HL)
	DEC	HL
	DEC	HL
	CALL	CPREG
	RET	NZ
	LD	(SPTPTR),HL
	RET
;
;STANDARDFUNKTIONEN FUER STRINGBEHANDLUNG
LEN:	LD	BC,POS1
	PUSH	BC
LEN1:	CALL	STRZSP
	XOR	A
	LD	D,A
	LD	(DATYPE),A
	LD	A,(HL)
	OR	A
	RET

ASC:	LD	BC,POS1
	PUSH	BC
ASC1:	CALL	LEN1
	JR	Z,MID_2
	INC	HL
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	A,(DE)
	RET

CHR_:	LD	A,1
	CALL	STADTB
	CALL	ARGVL2
	LD	HL,(STRDAT+2)
	LD	(HL),E
CHR_1:	POP	BC
CHR_2:	JP	SLEN3
 
LEFT_:	CALL	STREND
	XOR	A
LEFT_1:	EX	(SP),HL
	LD	C,A
LEFT_2:	PUSH	HL
	LD	A,(HL)
	CP	B
	JR	C,LEFT_3
	LD	A,B
	DEFB	11H
LEFT_3:	LD	C,0
	PUSH	BC
	CALL	STROP
	POP	BC
	POP	HL
	PUSH	HL
	INC	HL
	INC	HL
	LD	B,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,B
	LD	B,0
	ADD	HL,BC
	LD	B,H
	LD	C,L
	CALL	SADTB1
	LD	L,A
	CALL	STRMV1
	POP	DE
	CALL	STRZS3
	JR	CHR_2
 
RGHT_:	CALL	STREND
	POP	DE
	PUSH	DE
	LD	A,(DE)
	SUB	B
	JR	LEFT_1
 
MID_:	EX	DE,HL
	LD	A,(HL)
	CALL	STRED1
	INC	B
	DEC	B
MID_2:	JP	Z,FCER
	PUSH	BC
	LD	E,-1
	CP	')'
	JR	Z,MID_1
	CALL	CPCOMM
	CALL	ARGVL1
MID_1:	CALL	CPBRGT
	POP	AF
	EX	(SP),HL
	LD	BC,LEFT_2
	PUSH	BC
	DEC	A
	CP	(HL)
	LD	B,0
	RET	NC
	LD	C,A
	LD	A,(HL)
	SUB	C
	CP	E
	LD	B,A
	RET	C
	LD	B,E
	RET

VAL:	CALL	LEN1
	JP	Z,ADD12
	LD	E,A
	INC	HL
	INC	HL
	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A
	PUSH	HL
	ADD	HL,DE
	LD	B,(HL)
	LD	(HL),D
	EX	(SP),HL
	PUSH	BC
	LD	A,(HL)
	CALL	VALNRM
	POP	BC
	POP	HL
	LD	(HL),B
	RET

STREND:	EX	DE,HL
	CALL	CPBRGT
STRED1:	POP	BC
	POP	DE
	PUSH	BC
	LD	B,E
	RET
;
;EIN-AUSGEBE FUER RECHNERPORTS
INP:	CALL	ARGVL2
	LD	C,A
	IN	A,(C)
INP1:	JP	POS1
 
OUT:	CALL	ARGVL0
	LD	A,(PORTAD)
	LD	C,A
	LD	A,E
	OUT	(C),A
	RET

WAIT:	CALL	ARGVL0
	PUSH	AF
	LD	E,0
	CALL	TCHAR1
	JR	Z,WAIT1
	CALL	CPCOMM
	CALL	ARGVL1
WAIT1:	POP	BC
	LD	A,(PORTAD)
	LD	C,A
WAIT2:	IN	A,(C)
	XOR	E
	AND	B
	JR	Z,WAIT2
	RET

ARGVL0:	CALL	ARGVL1
	LD	(PORTAD),A
	CALL	CPCOMM
	DEC	HL
ARGVAL:	CALL	TCHAR
ARGVL1:	CALL	SNALY2
ARGVL2:	CALL	EPRVL2
	LD	A,D
	OR	A
	JP	NZ,FCER
	CALL	TCHAR1
	LD	A,E
	RET
;
;SPEICHERMANIPULATION
PEEK:	CALL	EPRVL3
	LD	A,(DE)
	JR	INP1
 
POKE:	CALL	EPRVL4
	PUSH	DE
	CALL	CPCOMM
	CALL	ARGVL1
	POP	DE
	LD	(DE),A
	RET

DEEK:	CALL	EPRVL3
	EX	DE,HL
	LD	B,(HL)
	INC	HL
	LD	A,(HL)
	JP	FRE3
 
DOKE:	CALL	EPRVL4
	PUSH	DE
	CALL	CPCOMM
	CALL	EPRVL4
	EX	(SP),HL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	POP	HL
	RET
;
;ARITHMETIKMODUL
;ADDITION UND SUBTRAKTION
ADD1:	LD	HL,SQRL
ADD2:	CALL	OPLAD
	JR	ADD5
	;
ADD3:	CALL	OPLAD
	DEFB	21H
MINUS:	POP	BC
	POP	DE
ADD4:	CALL	ABS1
ADD5:	LD	A,B
	OR	A
	RET	Z
	LD	A,(WRA1+3)
	OR	A
	JP	Z,OPKOP1
	SUB	B
	JR	NC,ADD7
	CPL
	INC	A
	EX	DE,HL
	CALL	OPARST
	EX	DE,HL
	CALL	OPKOP1
ADD6:	POP	BC
	POP	DE
ADD7:	CP	19H
	RET	NC
	PUSH	AF
	CALL	VORZ
	LD	H,A
	POP	AF
	CALL	ADD21
	OR	H
	LD	HL,WRA1
	JP	P,ADD8
	CALL	ADD19
	JR	NC,ADD16
	INC	HL
	INC	(HL)
	JR	Z,ADD26
	LD	L,1
	CALL	ADD25
	JR	ADD16
 
ADD8:	XOR	A
	SUB	B
	LD	B,A
	LD	A,(HL)
	SBC	A,E
	LD	E,A
	INC	HL
	LD	A,(HL)
	SBC	A,D
	LD	D,A
	INC	HL
	LD	A,(HL)
	SBC	A,C
	LD	C,A
ADD9:	CALL	C,ADD20
ADD10:	LD	L,B
	LD	H,E
	XOR	A
ADD11:	LD	B,A
	LD	A,C
	OR	A
	JR	NZ,ADD15
	LD	C,D
	LD	D,H
	LD	H,L
	LD	L,A
	LD	A,B
	SUB	8
	CP	0E0H
	JR	NZ,ADD11
ADD12:	XOR	A
ADD13:	LD	(WRA1+3),A
	RET
	;
ADD14:	DEC	B
	ADD	HL,HL
	RL	D
	RL	C
ADD15:	JP	P,ADD14
	LD	A,B
	LD	E,H
	LD	B,L
	OR	A
	JR	Z,ADD16
	LD	HL,WRA1+3
	ADD	A,(HL)
	LD	(HL),A
	JR	NC,ADD12
	RET	Z
ADD16:	LD	A,B
ADD17:	LD	HL,WRA1+3
	OR	A
	CALL	M,ADD18
	LD	B,(HL)
	INC	HL
	LD	A,(HL)
	AND	80H
	XOR	C
	LD	C,A
	JP	OPKOP1
 
ADD18:	INC	E
	RET	NZ
	INC	D
	RET	NZ
	INC	C
	RET	NZ
	LD	C,80H
	INC	(HL)
	RET	NZ
ADD26:	JP	OVER
 
ADD19:	LD	A,(HL)
	ADD	A,E
	LD	E,A
	INC	HL
	LD	A,(HL)
	ADC	A,D
	LD	D,A
	INC	HL
	LD	A,(HL)
	ADC	A,C
	LD	C,A
	RET

ADD20:	LD	HL,SGNORS
	LD	A,(HL)
	CPL
	LD	(HL),A
	XOR	A
	LD	L,A
	SUB	B
	LD	B,A
	LD	A,L
	SBC	A,E
	LD	E,A
	LD	A,L
	SBC	A,D
	LD	D,A
	LD	A,L
	SBC	A,C
	LD	C,A
	RET

ADD21:	LD	B,0
ADD22:	SUB	8
	JR	C,ADD23
	LD	B,E
	LD	E,D
	LD	D,C
	LD	C,0
	JR	ADD22
 
ADD23:	ADD	A,9
	LD	L,A
ADD24:	XOR	A
	DEC	L
	RET	Z
	LD	A,C
ADD25:	RRA
	LD	C,A
	RR	D
	RR	E
	RR	B
	JR	ADD24
;
;LOGARITHMUS
;KONSTANTENLISTE FUER LN-FUNKTION
LOGL:	DEFW	0000H	;1.0
	DEFW	8100H
LOGL1:	DEFB	03H	;ANZAHL DER GLIEDER DER REIHE
	DEFW	56AAH	; .5988
	DEFW	8019H
	DEFW	22F1H	; .96145
	DEFW	8076H
	DEFW	0AA45H	;2.88539
	DEFW	8238H
 
LOG:	CALL	TSGNM
	OR	A
	JP	PE,FCER
	LD	HL,WRA1+3
	LD	A,(HL)
	LD	BC,8035H	; .707092
	LD	DE,04F3H
	SUB	B
	PUSH	AF
	LD	(HL),B
	PUSH	DE
	PUSH	BC
	CALL	ADD5
	POP	BC
	POP	DE
	INC	B
	CALL	DIV1
	LD	HL,LOGL
	CALL	ADD3
	LD	HL,LOGL1
	CALL	REIHE
	LD	BC,8080H	;-.5
	LD	DE,0
	CALL	ADD5
	POP	AF
	CALL	PLUS0
LOG1:	LD	BC,8031H	; .693115
	LD	DE,7218H
	DEFB	21H
;
;MULTIPLIKATION UND DIVISION
MUL:	POP	BC
	POP	DE
MUL1:	CALL	TSGNM
	RET	Z
	LD	L,0
	CALL	HIROU1
	LD	A,C
	LD	(WRA2),A
	EX	DE,HL
	LD	(WRA2+1),HL
	LD	BC,0
	LD	D,B
	LD	E,B
	LD	HL,ADD10
	PUSH	HL
	LD	HL,MUL2
	PUSH	HL
	PUSH	HL
	LD	HL,WRA1
MUL2:	LD	A,(HL)
	INC	HL
	OR	A
	JR	Z,MUL6
	PUSH	HL
	LD	L,8
MUL3:	RRA
	LD	H,A
	LD	A,C
	JR	NC,MUL4
	PUSH	HL
	LD	HL,(WRA2+1)
	ADD	HL,DE
	EX	DE,HL
	POP	HL
	LD	A,(WRA2)
	ADC	A,C
MUL4:	RRA
	LD	C,A
	RR	D
	RR	E
	RR	B
	DEC	L
	LD	A,H
	JR	NZ,MUL3
MUL5:	POP	HL
	RET
	;
MUL6:	LD	B,E
	LD	E,D
	LD	D,C
	LD	C,A
	RET

DIV0:	CALL	OPARST
	LD	BC,8420H	;10.0
	LD	DE,0
	CALL	OPKOP1
DIV:	POP	BC
	POP	DE
DIV1:	CALL	TSGNM
	JP	Z,DIVER
	LD	L,-1
	CALL	HIROU1
	INC	(HL)
	INC	(HL)
	DEC	HL
	LD	A,(HL)
	LD	(DVAR3),A
	DEC	HL
	LD	A,(HL)
	LD	(DVAR2),A
	DEC	HL
	LD	A,(HL)
	LD	(DVAR1),A
	LD	B,C
	EX	DE,HL
	XOR	A
	LD	C,A
	LD	D,A
	LD	E,A
	LD	(DVAR4),A
DIV2:	PUSH	HL
	PUSH	BC
	LD	A,L
	CALL	DIVVAR
	SBC	A,0
	CCF
	JR	NC,DIV3
	LD	(DVAR4),A
	POP	AF
	POP	AF
	SCF
	DEFB	0D2H
DIV3:	POP	BC
	POP	HL
	LD	A,C
	INC	A
	DEC	A
	RRA
	JP	M,ADD17
	RLA
	RL	E
	RL	D
	RL	C
	ADD	HL,HL
	RL	B
	LD	A,(DVAR4)
	RLA
	LD	(DVAR4),A
	LD	A,C
	OR	D
	OR	E
	JR	NZ,DIV2
	PUSH	HL
	LD	HL,WRA1+3
	DEC	(HL)
	POP	HL
	JR	NZ,DIV2
OVER:	LD	E,10		; OV-ERROR
	JP	ERROO
;
;HILFSROUTINEN FUER ARITHMETIK
HIROU1:	LD	A,B
	OR	A
	JP	Z,HIROU4
	LD	A,L
	LD	HL,WRA1+3
	XOR	(HL)
	ADD	A,B
	LD	B,A
	RRA
	XOR	B
	LD	A,B
	JP	P,HIROU3
	ADD	A,80H
	LD	(HL),A
	JP	Z,MUL5
	CALL	VORZ
	LD	(HL),A
	DEC	HL
	RET

HIROU2:	CALL	TSGNM
	CPL
	POP	HL
HIROU3:	OR	A
HIROU4:	POP	HL
	JP	P,ADD12
	JR	OVER
 
HIROU5:	CALL	OPLAD0
	LD	A,B
	OR	A
	RET	Z
	ADD	A,2
	JR	C,OVER
	LD	B,A
	CALL	ADD5
	LD	HL,WRA1+3
	INC	(HL)
	RET	NZ
	JR	OVER
 
;VORZEICHENTEST
TSGNM:	LD	A,(WRA1+3)
	OR	A
	RET	Z
	LD	A,(WRA1+2)
	DEFB	0FEH
TSGNM1:	CPL
	RLA
TSGNM2:	SBC	A,A
	RET	NZ
	INC	A
	RET

SGN:	CALL	TSGNM
SGN0:	LD	B,88H
	LD	DE,0
SGN1:	LD	HL,WRA1+3
	LD	C,A
	LD	(HL),B
	LD	B,0
	INC	HL
	LD	(HL),80H
	RLA
	JP	ADD9
 
ABS:	CALL	TSGNM
	RET	P
ABS1:	LD	HL,WRA1+2
	LD	A,(HL)
	XOR	80H
	LD	(HL),A
	RET

OPARST:	EX	DE,HL
	LD	HL,(WRA1)
	EX	(SP),HL
	PUSH	HL
	LD	HL,(WRA1+2)
	EX	(SP),HL
	PUSH	HL
	EX	DE,HL
	RET

PI:	LD	BC,8249H	;PI
	LD	DE,0FDBH
	JR	OPKOP1
 
OPKOP:	CALL	OPLAD
OPKOP1:	LD	(WRA1),DE
	LD	(WRA1+2),BC
	LD	D,B
	LD	E,C
	RET

OPLAD0:	LD	HL,WRA1
;ZAHL AUS SPEICHER IN REGISTER BCDE LADEN
;ZEIGER IN REGISTER HL
OPLAD:	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	INC	HL
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
OPLAD1:	INC	HL
	RET

OPTRAN:	LD	DE,WRA1
OPTRN1:	LD	B,4
OPTRN2:	LD	A,(DE)
	LD	(HL),A
	INC	DE
	INC	HL
	DJNZ	OPTRN2
	RET

VORZ:	LD	HL,WRA1+2
	LD	A,(HL)
	RLCA
	SCF
	RRA
	LD	(HL),A
	CCF
	RRA
	INC	HL
	INC	HL
	LD	(HL),A
	LD	A,C
	RLCA
	SCF
	RRA
	LD	C,A
	RRA
	XOR	(HL)
	RET

VORZ1:	LD	A,B
	OR	A
	JP	Z,TSGNM
	LD	HL,TSGNM1
	PUSH	HL
	CALL	TSGNM
	LD	A,C
	RET	Z
	LD	HL,WRA1+2
	XOR	(HL)
	LD	A,C
	RET	M
	CALL	CPOPER
	RRA
	XOR	C
	RET

CPOPER:	INC	HL
	LD	A,B
	CP	(HL)
	RET	NZ
	DEC	HL
	LD	A,C
	CP	(HL)
	RET	NZ
	DEC	HL
	LD	A,D
	CP	(HL)
	RET	NZ
	DEC	HL
	LD	A,E
	SUB	(HL)
	RET	NZ
	POP	HL
	POP	HL
	RET

INTMOV:	LD	B,A
	LD	C,A
	LD	D,A
	LD	E,A
	OR	A
	RET	Z
	PUSH	HL
	CALL	OPLAD0
	CALL	VORZ
	XOR	(HL)
	LD	H,A
	CALL	M,DEZERO
	LD	A,98H
	SUB	B
	CALL	ADD21
	LD	A,H
	RLA
	CALL	C,ADD18
	LD	B,0
	CALL	C,ADD20
	POP	HL
	RET

DEZERO:	DEC	DE
	LD	A,D
	AND	E
	INC	A
	RET	NZ
	DEC	BC
	RET

INT:	LD	HL,WRA1+3
	LD	A,(HL)
	CP	98H
	LD	A,(WRA1)
	RET	NC
	LD	A,(HL)
	CALL	INTMOV
	LD	(HL),98H
	LD	A,E
	PUSH	AF
	LD	A,C
	RLA
	CALL	ADD9
	POP	AF
	RET

FESRCH:	LD	HL,0
	LD	A,B
	OR	C
	RET	Z
	LD	A,16
FESRH1:	ADD	HL,HL
	JR	C,FESRH3
	EX	DE,HL
	ADD	HL,HL
	EX	DE,HL
	JR	NC,FESRH2
	ADD	HL,BC
FESRH3:	JP	C,BSER
FESRH2:	DEC	A
	JR	NZ,FESRH1
	RET

VALNRM:	CP	'-'
	PUSH	AF
	JR	Z,VALNR1
	CP	'+'
	JR	Z,VALNR1
	DEC	HL
VALNR1:	CALL	ADD12
	LD	B,A
	LD	D,A
	LD	E,A
	CPL
	LD	C,A
VALNR2:	CALL	TCHAR
	JR	C,VALN10
	CP	'.'
	JR	Z,VALNR4
	CP	'E'
	JR	NZ,VALNR5
	CALL	TCHAR
	CALL	SNLY22
VALNR3:	CALL	TCHAR
	JR	C,VALN11
	INC	D
	JR	NZ,VALNR5
	XOR	A
	SUB	E
	LD	E,A
	INC	C
VALNR4:	INC	C
	JR	Z,VALNR2
VALNR5:	PUSH	HL
	LD	A,E
	SUB	B
VALNR6:	CALL	P,VALNR8
	JP	P,VALNR7
	PUSH	AF
	CALL	DIV0
	POP	AF
	INC	A
VALNR7:	JR	NZ,VALNR6
	POP	DE
	POP	AF
	CALL	Z,ABS1
	EX	DE,HL
	RET

VALNR8:	RET	Z
VALNR9:	PUSH	AF
	CALL	HIROU5
	POP	AF
	DEC	A
	RET

VALN10:	PUSH	DE
	LD	D,A
	LD	A,B
	ADC	A,C
	LD	B,A
	PUSH	BC
	PUSH	HL
	PUSH	DE
	CALL	HIROU5
	POP	AF
	SUB	'0'
	CALL	PLUS0
	POP	HL
	POP	BC
	POP	DE
	JR	VALNR2
 
PLUS0:	CALL	OPARST
	CALL	SGN0
PLUS:	POP	BC
	POP	DE
	JP	ADD5
 
VALN11:	LD	A,E
	RLCA
	RLCA
	ADD	A,E
	RLCA
	ADD	A,(HL)
	SUB	'0'
	LD	E,A
	JR	VALNR3
;
;FORMATIERTE ZAHLENAUSGABE
INOUT:	PUSH	HL
	LD	HL,IN		; Zeichenkette "IN"
	CALL	TEXTO
	POP	HL
NUMBO:	EX	DE,HL
NUMBO1:	XOR	A
	LD	B,98H
	CALL	SGN1
	LD	HL,TEXTO0
	PUSH	HL
NUMKON:	LD	HL,INTPRB
	PUSH	HL
	CALL	TSGNM
	LD	(HL),' '
	JP	P,NORM1
	LD	(HL),'-'
NORM1:	INC	HL
	LD	(HL),'0'
	JP	Z,NORM12
	PUSH	HL
	CALL	M,ABS1
	XOR	A
	PUSH	AF
	CALL	NORM14
NORM2:	LD	BC,9143H	;99999.9
	LD	DE,4FF8H
	CALL	VORZ1
	OR	A
	JP	PO,NORM4
	POP	AF
	CALL	VALNR9
	PUSH	AF
	JR	NORM2
 
NORM3:	CALL	DIV0
	POP	AF
	INC	A
	PUSH	AF
	CALL	NORM14
NORM4:	CALL	ADD1
	INC	A
	CALL	INTMOV
	CALL	OPKOP1
	LD	BC,0306H
	POP	AF
	ADD	A,C
	INC	A
	JP	M,NORM5
	CP	8
	JR	NC,NORM5
	INC	A
	LD	B,A
	LD	A,2
NORM5:	DEC	A
	DEC	A
	POP	HL
	PUSH	AF
	LD	DE,POF10
	DEC	B
	JR	NZ,NORM6
	LD	(HL),'.'
	INC	HL
	LD	(HL),'0'
	INC	HL
NORM6:	DEC	B
	LD	(HL),'.'
	CALL	Z,OPLAD1
	PUSH	BC
	PUSH	HL
	PUSH	DE
	CALL	OPLAD0
	POP	HL
	LD	B,'0'-1
NORM7:	INC	B
	LD	A,E
	SUB	(HL)
	LD	E,A
	INC	HL
	LD	A,D
	SBC	A,(HL)
	LD	D,A
	INC	HL
	LD	A,C
	SBC	A,(HL)
	LD	C,A
	DEC	HL
	DEC	HL
	JR	NC,NORM7
	CALL	ADD19
	INC	HL
	CALL	OPKOP1
	EX	DE,HL
	POP	HL
	LD	(HL),B
	INC	HL
	POP	BC
	DEC	C
	JR	NZ,NORM6
	DEC	B
	JR	Z,NORM9
NORM8:	DEC	HL
	LD	A,(HL)
	CP	'0'
	JR	Z,NORM8
	CP	'.'
	CALL	NZ,OPLAD1
NORM9:	POP	AF
	JR	Z,NORM13
	LD	(HL),'E'
	INC	HL
	LD	(HL),'+'
	JP	P,NORM10
	LD	(HL),'-'
	CPL
	INC	A
NORM10:	LD	B,'0'-1
NORM11:	INC	B
	SUB	10
	JR	NC,NORM11
	ADD	A,'9'+1
	INC	HL
	LD	(HL),B
NORM12:	INC	HL
	LD	(HL),A
	INC	HL
NORM13:	LD	(HL),C
	POP	HL
	RET

NORM14:	LD	BC,9474H	;999999
	LD	DE,23F7H
	CALL	VORZ1
	OR	A
	POP	HL
	JP	PO,NORM3
	JP	(HL)

	;KONSTANTE FUER SQR-FUNKTION
SQRL:	DEFW	0000H	;.5
	DEFW	8000H
	;KONSTANTENLISTE FUER KONVERTIERUNG VON ZAHLEN
	;INS AUSGABEFORMAT
POF10:	DEFW	86A0H	;100000
	DEFB	01H
	DEFW	2710H	;10000
	DEFB	00H
	DEFW	03E8H	;1000
	DEFB	00H
	DEFW	0064H	;100
	DEFB	00H
	DEFW	000AH	;10
	DEFB	00H
	DEFW	0001H	;1
	DEFB	00H
;
;EXPONENTIALFUNKTION UND QUADRATWURZEL
EXPO3:	LD	HL,ABS1
	EX	(SP),HL
	JP	(HL)
 
SQR:	CALL	OPARST
	LD	HL,SQRL
	CALL	OPKOP
EXPO:	POP	BC
	POP	DE
	CALL	TSGNM
	LD	A,B
	JP	Z,EXP
	JP	P,EXPO1
	OR	A
	JP	Z,DIVER
EXPO1:	OR	A
	JP	Z,ADD13
	PUSH	DE
	PUSH	BC
	LD	A,C
	OR	7FH
	CALL	OPLAD0
	JP	P,EXPO2
	PUSH	DE
	PUSH	BC
	CALL	INT
	POP	BC
	POP	DE
	PUSH	AF
	CALL	VORZ1
	POP	HL
	LD	A,H
	RRA
EXPO2:	POP	HL
	LD	(WRA1+2),HL
	POP	HL
	LD	(WRA1),HL
	CALL	C,EXPO3
	CALL	Z,ABS1
	PUSH	DE
	PUSH	BC
	CALL	LOG
	POP	BC
	POP	DE
	CALL	MUL1
EXP:	CALL	OPARST
	LD	BC,8138H	;1.4427
	LD	DE,0AA3BH
	CALL	MUL1
	LD	A,(WRA1+3)
	CP	88H
	JP	NC,HIROU2
	CALL	INT
	ADD	A,80H
	ADD	A,2
	JP	C,HIROU2
	PUSH	AF
	LD	HL,LOGL
	CALL	ADD2
	CALL	LOG1
	POP	AF
	POP	BC
	POP	DE
	PUSH	AF
	CALL	ADD4
	CALL	ABS1
	LD	HL,EXPL
	CALL	REIHE1
	LD	DE,0
	POP	BC
	LD	C,D
	JP	MUL1
;
;KONSTANTENLISTE FUER REIHENENTWICKLUNG DER EXPONENTIALFUNKTION
EXPL:	DEFB	08H	;ANZAHL DER GLIEDER DER REIHE
	DEFW	2E40H	;-1.41316*10E-4
	DEFW	7494H
	DEFW	4F70H	; 1.32988*10E-3
	DEFW	772EH
	DEFW	026EH	;-8.30136*10E-3
	DEFW	7A88H
	DEFW	0A0E6H	;  .0416574
	DEFW	7C2AH
	DEFW	0AA50H	;- .166665
	DEFW	7EAAH
	DEFW	0FFFFH	;  .5
	DEFW	7F7FH
	DEFW	0000H	;-1.0
	DEFW	8180H
	DEFW	0000H	; 1.0
	DEFW	8100H
;
;ROUTINE ZUR ENTWICKLUNG VON FUNKTIONEN IN REIHEN
REIHE:	CALL	OPARST
	LD	DE,MUL
	PUSH	DE
	PUSH	HL
	CALL	OPLAD0
	CALL	MUL1
	POP	HL
REIHE1:	CALL	OPARST
	LD	A,(HL)
	INC	HL
	CALL	OPKOP
	DEFB	06H
REIHE2:	POP	AF
	POP	BC
	POP	DE
	DEC	A
	RET	Z
	PUSH	DE
	PUSH	BC
	PUSH	AF
	PUSH	HL
	CALL	MUL1
	POP	HL
	CALL	OPLAD
	PUSH	HL
	CALL	ADD5
	POP	HL
	JR	REIHE2
;
;ZUFALLSZAHLERZEUGUNG
RND:	CALL	TSGNM		; Vorzeichentest von WRA1
				;PA: WRA1>0:    A=1,    SF=0, ZF=0
				;    WRA1=0:    A=0,    SF=0, ZF=1
				;    WRA1<0:    A=0FFh, SF=1, ZF=0
	LD	HL,RNDVR3
	JP	M,RND3		; Sprung bei RND mit X<0
	LD	HL,RNDVR4
	CALL	OPKOP		; RNDVR4 => WRA1
	LD	HL,RNDVR3	; Index von Konstantenfeld (RNDVR3+1)
	RET	Z		; raus bei RND mit X=0
; RND mit X>0:
; Multipliziere RNDVR4 mit Konstante im WSP
	ADD	A,(HL)		; +RNDVR3 (A ist 1)
	AND	7		; Wertebereich 0..7
	LD	B,0
	LD	(HL),A
	INC	HL		; HL auf Konstantenfeld im WSP
	ADD	A,A		; Index*2
	ADD	A,A		;      *4
	LD	C,A
	ADD	HL,BC		; Adr. der indizierten Konstante im WSP
	CALL	OPLAD		; nach BCDE laden
	CALL	MUL1		; BCDE mit WRA1 multiplizieren
; Addiere WRA1 mit Konstante im ROM
	LD	A,(RNDVR2)	; Index auf Konstantenfeld im ROM (RNDL)
	INC	A		; naechster Index
	AND	3
	LD	B,0
	CP	1
	ADC	A,B		; Wertebereich 1..3
	LD	(RNDVR2),A
	LD	HL,RNDL-4H
	ADD	A,A
	ADD	A,A
	LD	C,A
	ADD	HL,BC		; Adr. der indizierten Konstante im ROM
	CALL	ADD2		; mit WRA1 addieren
; fuer WRA1 eine bestimmte Zufallszahl ermitteln
RND1:	CALL	OPLAD0		; WRA1 nach BCDE, HL auf SGNORS
	LD	A,E		; Mantisse veraendern
	LD	E,C
	XOR	4FH
	LD	C,A
	LD	(HL),80H	; fuer ADD10:positive Zahl
	DEC	HL		; HL auf Exponent von WRA1
	LD	B,(HL)
	LD	(HL),80H	; Exponent auf +0
	LD	HL,RNDVR1
	INC	(HL)		; Zaehler
	LD	A,(HL)
	SUB	0ABH		; wenn = 171
	JR	NZ,RND2
	LD	(HL),A		; zuruecksetzen und Mantisse veraendern
	INC	C
	DEC	D
	INC	E
RND2:	CALL	ADD10		; Korrektur der Zahl und speichern in WRA1
	LD	HL,RNDVR4
	JP	OPTRAN		; nach RNDVR4 kopieren

; RND mit X<0:
; Argument in eine bestimmte Zufallszahl umrechnen
RND3:	LD	(HL),A		; A ist 0FFh vom Vorzeichentest
	DEC	HL		; RNDVR1..3 auf 0FFh setzen
	LD	(HL),A		; RNDVR2 und 3 werden beim naechsten Aufruf
	DEC	HL		; von RND(1) auf den Anfang der Indizes
	LD	(HL),A		; gesetzt
	JR	RND1

; Aufbau der Gleitkommazahl:
; https://hc-ddr.hucki.net/wiki/doku.php/z9001/basic

;KONSTANTENLISTE FUER ZUFALLSZAHLERZEUGUNG
RNDL:	DEFW	0B168H	; 4.62618*10E-8
	DEFW	6846H
	DEFW	0E999H	;-6.84115*10E-8
	DEFW	6992H
	DEFW	0D110H	; 5.72337*10E-8
	DEFW	6875H
;
;TRIGONOMETRISCHE FUNKTIONEN
COS:	LD	HL,COSL
	CALL	ADD2
SIN:	CALL	OPARST
	LD	BC,8349H	;6.28319
	LD	DE,0FDBH
	CALL	OPKOP1
	POP	BC
	POP	DE
	CALL	DIV1
	CALL	OPARST
	CALL	INT
	POP	BC
	POP	DE
	CALL	ADD4
	LD	HL,SINL1
	CALL	ADD3
	CALL	TSGNM
	SCF
	JP	P,SIN1
	CALL	ADD1
	CALL	TSGNM
	OR	A
SIN1:	PUSH	AF
	CALL	P,ABS1
	LD	HL,SINL1
	CALL	ADD2
	POP	AF
	CALL	NC,ABS1
	LD	HL,SINL
	JP	REIHE
 
;KONSTANTE FUER UEBERFUEHRUNG DER BERECHNUNG
;DES COS(X) IN DIE BERECHNUNG SN(F(X))
COSL:	DEFW	0FDBH	; PI/2
	DEFW	8149H
 
;KONSTANTENLISTE FUER ENTWICKLUNG DER SINUS-
;FUNKTION IN EINER REIHE
SINL1:	DEFW	0000H	;  .25
	DEFW	7F00H
SINL:	DEFB	05H	;ANZAHL DER GLIEDER DER REIHE
	DEFW	0D7BAH	;39.7107
	DEFW	861EH
	DEFW	2664H	;-76.575
	DEFW	8799H
	DEFW	3458H	;81.6022
	DEFW	8723H
	DEFW	5DE0H	;-41.3417
	DEFW	86A5H
	DEFW	0FDAH	;  6.28319
	DEFW	8349H
 
TAN:	CALL	OPARST
	CALL	SIN
	POP	BC
	POP	HL
	CALL	OPARST
	EX	DE,HL
	CALL	OPKOP1
	CALL	COS
	JP	DIV
 
ATN:	CALL	TSGNM
	CALL	M,EXPO3
	CALL	M,ABS1
	LD	A,(WRA1+3)
	CP	81H
	JP	C,ATN1
	LD	BC,8100H	;1.0
	LD	D,C
	LD	E,C
	CALL	DIV1
	LD	HL,ADD3
	PUSH	HL
ATN1:	LD	HL,ATNL
	CALL	REIHE
	LD	HL,COSL
	RET

;KONSTANTENLISTE FUER REIHENENTWICKLUNG DER
;ARCUS-TANGENS-FUNKTION
ATNL:	DEFB	09H	;ANZAHL DER GLIEDER DER REIHE
	DEFW	0D74AH	; 2.86623*10E-3
	DEFW	783BH
	DEFW	6E02H	;- .0161657
	DEFW	7B84H
	DEFW	0C1FEH	;  .0429096
	DEFW	7C2FH
	DEFW	3174H	;- .0752896
	DEFW	7D9AH
	DEFW	3D84H	;  .105586
	DEFW	7D5AH
	DEFW	7FC8H	;- .142089
	DEFW	7E91H
	DEFW	0BBE4H	;- .199936
	DEFW	7E4CH
	DEFW	0AA6CH	;- .333331
	DEFW	7FAAH
	DEFW	0000H	; 1.0
	DEFW	8100H
;
;AUFRUF VON MASCHINENPROGRAMMEN
CALL:	CALL	HEX
	JR	Z,CALL1
	CALL	EPRVL4
CALL1:	PUSH	HL
	LD	HL,CALL2
	PUSH	HL
	EX	DE,HL
	JP	(HL)
 
CALL2:	POP	HL
	RET

HEX:	CP	MULTOK
	RET	NZ
	LD	DE,0
HEX1:	CALL	TCHAR
	RET	Z
	JR	C,HEX2
	CP	DEFTOK
	JR	Z,HEX3
	CP	'G'
	JP	NC,SNER
	SUB	7
HEX2:	SUB	'0'
	JP	C,SNER
	EX	DE,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	OR	L
	LD	L,A
	EX	DE,HL
	JR	HEX1
	;
HEX3:	LD	A,E
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
	OR	0DH
	LD	D,A
	LD	E,0EFH
	JR	HEX1
;
;KASSETTEN-EIN/AUSGABEROUTINEN
CLOAD_:	PUSH	DE
	PUSH	HL
CLOA_1:	LD	(HL),0		;ALLE LAENGEN = 0
	INC	HL
	CALL	CPREG
	JR	NZ,CLOA_1
	EX	(SP),HL
	PUSH	HL
	CALL	STRZS1
	CALL	STROP4
	LD	HL,(SWAPTR)
	LD	DE,(STDPTR)
	XOR	A
	SBC	HL,DE
	POP	DE
	EX	(SP),HL
	SBC	HL,DE
	PUSH	HL
	CALL	INIT8I		; Datei oeffnen, erstes Byte einlesen
	LD	C,A
	CALL	CI
	LD	B,A
	POP	HL
CLOA_2:	CALL	CI
	LD	(DE),A
	INC	DE
	DEC	HL
	LD	A,L
	OR	H
	JR	NZ,CLOA_2
	POP	HL
	CALL	CI
	LD	E,A
	CALL	CI
	LD	D,A
	XOR	A		; CY=0
	SBC	HL,DE
	JR	C,CLOA_7
	LD	HL,(STDPTR)
	INC	HL
CLOA_3:	CALL	CI
	LD	(HL),A
	INC	HL
	DEC	DE
	LD	A,E
	OR	D
	JR	NZ,CLOA_3
	POP	DE
	EX	(SP),HL
	PUSH	BC
	CALL	CHSUM
	EX	(SP),HL
	SBC	HL,BC
	JR	NZ,CLOA_6
	POP	HL
	CALL	LAENGE
	EX	(SP),HL
	DEC	HL
	PUSH	DE
	LD	DE,(SWAPTR)
	LDDR
	LD	(SWAPTR),DE
	POP	HL
	LD	B,D
	LD	C,E
	INC	BC
	POP	DE
CLOA_4:	DEC	HL
	LD	(HL),B
	DEC	HL
	LD	(HL),C
	DEC	HL
CLOA_5:	DEC	(HL)
	INC	BC
	JR	NZ,CLOA_5
	DEC	BC
	DEC	HL
	CALL	CPREG
	JR	NZ,CLOA_4
	POP	HL
CLOA_8:	CALL	CLCHNL		; alle benutzten Kanaele schliessen
	RET
	;
CLOA_7:	POP	DE
	POP	HL
CLOA_6:	LD	(HL),0
	INC	HL
	CALL	CPREG
	JR	NZ,CLOA_6
	JR	CLOAD3
 
; Variablenfeld laden mit CLOAD*
CLOADD:	CALL	CASS00
	PUSH	HL
	JP	PO,CLOAD_
	EX	DE,HL
	SBC	HL,DE
	PUSH	HL
	CALL	INIT8I		; Datei oeffnen, erstes Byte einlesen
	LD	C,A
	CALL	CI
	LD	B,A
	POP	HL
CLOAD2:
	CALL	CI
	LD	(DE),A
	INC	DE
	DEC	HL
	LD	A,L
	OR	H
	JR	NZ,CLOAD2
	POP	HL
	PUSH	BC
	CALL	CHSUM
	POP	HL
	SBC	HL,BC
	POP	HL
	JR	Z,CLOA_8
CLOAD3:	CALL	SETCO
	LD	HL,BAD
	JP	ERROO1
BAD:	DEFM	'BAD'
	DEFB	0
 
CLOAD:	CP	MULTOK		; folgt ein *
	JR	Z,CLOADD	; dann Variablenfeld
	; Programm einlesen
	CALL	CASS01		; *.SSS Name holen
	LD	DE,(SVARPT)	; Programmende+1
	DEC	DE
	DEC	DE
	LD	HL,0
	ADD	HL,SP		; HL = Stackpointer
	LD	BC,-47
	SBC	HL,DE		; minus aktuelles Programmende
	ADD	HL,BC		; minus 47 Byte
	LD	B,H
	LD	C,L		; BC = freier Speicherplatz
	CALL	INIT8I		; Datei oeffnen, erstes Byte einlesen
	LD	L,A
	CALL	CI		; zweites Byte lesen
	LD	H,A		; HL = Programmlaenge
	PUSH	HL
	SBC	HL,BC		; freier Speicher ausreichend?
	POP	HL
	JP	NC,OMER		; nein -> OM ERROR
CLOAD1:	CALL	CI		; Byte lesen
	LD	(DE),A		; Byte in Speicher
	INC	DE
	DEC	HL
	LD	A,L
	OR	H
	JR	NZ,CLOAD1	; bis HL=0
	LD	(SVARPT),DE	; Programmende
	LD	HL,FILE		; FILE FOUND
	CALL	TEXTO
	JP	LIN10
 
IOERR:	LD	E,38		; IO-ERROR
	JP	ERROO
 
CASS00:	CALL	CASS0		; *.TTT
	POP	HL
	CALL	CPSTX
	DEFB	';'
	LD	A,1
	LD	(FORFLG),A
	CALL	DIM1
	LD	(FORFLG),A
	EX	(SP),HL
	PUSH	HL
	LD	H,B
	LD	L,C
	EX	DE,HL
	ADD	HL,DE
	EX	DE,HL
	LD	C,(HL)
	LD	B,0
	ADD	HL,BC
	ADD	HL,BC
	INC	HL
	LD	A,(DATYPE)
	OR	A
	RET

CASS0:	LD	A,D4TYPE	; TTT = Variablenfeld
	INC	HL
	DEFB	1
CASS01:	LD	A,D3TYPE	; SSS = BASIC-Programm
CASS1:	PUSH	AF
	LD	A,(DATBYT)	; geschuetzte Datei erzeugen?
	AND	A
	LD	A,0		; nur einmalig, dann gleich wieder ruecksetzen
	LD	(DATBYT),A
	JR	Z,CASS5
	POP	AF
	ADD	A,4		; SSS => WWW / TTT => XXX / UUU => YYY
	PUSH	AF
CASS5:	CALL	TCHAR1
	CALL	SNALY
	POP	AF
	EX	(SP),HL
	PUSH	HL
	PUSH	AF
	CALL	ASC1
	LD	HL,INTPRB+13	; PRINTPUFFER ENDE
	LD	B,13
CASS2:	DEC	HL
	LD	(HL),' '	; mit Leerzeichen vorbelegen
	DJNZ	CASS2
	PUSH	DE
	LD	DE,IOERR
	LD	(HL),E		; als Erstes Fehlersprung eintragen
	INC	HL
	LD	(HL),D
	POP	DE
	INC	HL
	POP	AF
	LD	(HL),A		; dann 3x Dateityp
	INC	HL
	LD	(HL),A
	INC	HL
	LD	(HL),A
	INC	HL
	EX	DE,HL
	LD	B,0
CASS3:	LD	A,C		; Anzahl Zeichen
	CP	9		; kleiner als 9
	JR	C,CASS4		; dann kopieren
	DEC	C
	INC	HL		; ansonsten nur die letzten 8 Zeichen
	JR	CASS3
	;
CASS4:	LDIR
	RET

CHSUM:	PUSH	HL
	XOR	A
	LD	B,A
CHSUM1:	ADD	A,(HL)
	CALL	CHSUM2
	JR	NZ,CHSUM1
	POP	HL
	RET

CHSUM2:	LD	C,A
	JR	NC,CHSUM3
	INC	B
CHSUM3:	INC	HL
	CALL	CPREG
	LD	A,C
	RET

;ROUTINE ZUM SETZEN OCH_ (8 BIT)
INIT8O:	PUSH	AF
	LD	A,(IOCHNL)	; E/A-Flag
	BIT	OM_,A		; Bit 1
	SET	OM_,A		; Bit 1
	LD	(IOCHNL),A	; E/A-Flag
	LD	A,OCH_+BIT8	; Kassettenausgabe 8 Bit
	JR	NZ,SETOO1
	ADD	A,INIT		; INIT-Bit setzen
SETOO1:	LD	(OUTIND),A	; OUT-Index einstellen
;-------------------------
	LD	HL,INTPRB	; PRINT-Puffer (Dateiname)
	POP	AF
	JP	CO		; Byte ausgeben

;ROUTINE ZUM SETZEN ICH_ (8 BIT)
INIT8I:	LD	A,(IOCHNL)	; E/A-Flag
	BIT	IM_,A		; Bit 0?
	SET	IM_,A		; Bit 0 setzen
	LD	(IOCHNL),A	; E/A-Flag
	LD	A,ICH_+BIT8	; Kassetteneingabe 8 Bit
	JR	NZ,SETOI1
	ADD	A,INIT		; INIT-Bit setzen
SETOI1:	LD	(ININD),A	; IN-Index
;------------------------
	LD	HL,INTPRB	; PRINT-Puffer (Dateiname)
	JP	CI		; Byte einlesen
 
CSAVE:	CP	MULTOK		; folgt ein *
	JR	Z,CSAVED	; dann Variablenfeld
	CALL	IOTEST		; LIST/EDIT/BYE-Schutz?
	CALL	CASS01
	LD	HL,(SVARPT)
	LD	DE,-PRAM
	ADD	HL,DE
	LD	B,H
	LD	C,L
	LD	DE,PRAM
CSAVE0:	CALL	CSAVE2
CSAVE4:	POP	HL
;ROUTINE ZUM SCHLIEZSEN OCH_ (8 BIT)
RES8OO:	PUSH	HL
	LD	HL,IOCHNL
	RES	OM_,(HL)	; Bit 1
	LD	DE,0300H+OCH_+CLOSE
	CALL	IO
	POP	HL
	RET

; Variablenfeld speichern mit CSAVE*
CSAVED:	CALL	CASS00
	JP	PO,CSAVE_
	CALL	CHSUM
	EX	DE,HL
	SBC	HL,DE
	JR	CSAVE0
 
LAENGE:	PUSH	HL
	LD	BC,0
LAENG1:	LD	A,(HL)
	INC	HL
	LD	(HL),A
	INC	(HL)
	ADD	A,C
	INC	HL
	INC	HL
	CALL	CHSUM2
	JR	NZ,LAENG1
	POP	HL
	RET

CSAVE_:	CALL	LAENGE
	PUSH	BC
	CALL	CHSUM
	EX	DE,HL
	SBC	HL,DE
	CALL	CSAVE2
	POP	BC
	LD	A,C
	CALL	CO
	LD	A,B
	EX	DE,HL
	CALL	CO
CSAV_2:	DEC	HL
	DEC	HL
	LD	A,B
	OR	C
	JR	Z,CSAVE4
	LD	D,(HL)
	DEC	HL
	LD	E,(HL)
	DEC	HL
CSAV_3:	DEC	(HL)
	JR	Z,CSAV_2
	LD	A,(DE)
	CALL	CO
	INC	DE
	DEC	BC
	JR	CSAV_3
 
CSAVE2:	INC	HL
	PUSH	HL
	LD	A,C
	CALL	INIT8O
	LD	A,B
	POP	HL
CSAVE1:
	CALL	CO
	DEC	HL
	LD	A,L
	OR	H
	LD	A,(DE)
	INC	DE
	JR	NZ,CSAVE1
	RET

D3TYPE	EQU	0D3H
D4TYPE	EQU	0D4H
D5TYPE	EQU	0D5H
 
;
;EIN/AUSGABE-SCHNITTSTELLE VARIABLENVEREINBARUNG
CICH	EQU	00		; Eingabe Kanal 0 = Tastatur
COCH	EQU	01		; Ausgabe Kanal 0 = Bildschirm
ICH_	EQU	02		; Eingabe Kanal 1 = Kassette
OCH_	EQU	03		; Ausgabe Kanal 1 = Kassette
ICH?	EQU	04		; Eingabe Kanal 2 = Anwenderkanal 1
OCH?	EQU	05		; Ausgabe Kanal 2 = Anwenderkanal 1
ICH??	EQU	06		; Eingabe Kanal 3 = Anwenderkanal 2
OCH??	EQU	07		; Ausgabe Kanal 3 = Anwenderkanal 2
MONIT	EQU	0FFH		; Bit 5 = Code fuer Ruecksprung zu CAOS
IMRET	EQU	80H		; Bit 7 = Abfrage Tastaturstatus
CLOSE	EQU	40H		; Bit 6 = Close
INIT	EQU	08H		; Bit 3 = Init
BIT8	EQU	10H		; Bit 4

;TEST, OB COCH (Bildschirmausgabe) GESETZT IST
TESTCO:	LD	A,(OUTIND)	; OUT-Index
	AND	OCH??
	SUB	COCH
	RET

;BILDSCHIRM LOESCHEN
CLS:	CALL	SETCO
	LD	A,0CH
 
;AUSGABE EINES ZEICHENS
CO:	PUSH	AF
	PUSH	DE
	LD	D,A
	LD	A,(OUTIND)	; OUT-Index
	LD	E,A
	LD	A,D
	CALL	IO
	LD	A,E
	POP	DE
	JR	SETCO1		; OUT-Index aktualisieren
 
;EINGABE EINES ZEICHENS
CI:	PUSH	DE
	LD	A,(ININD)	; IN-Index
	LD	E,A
	CALL	IO
	LD	A,E
	LD	(ININD),A	; IN-Index
	LD	A,D		; gelesenes Zeichen
	JR	CSTS1
 
; Konsolen(Tastatur-)status abfragen vom CICH
CSTS:	PUSH	DE
	LD	E,CICH+IMRET
	CALL	IO		; Tastaturstatusabfrage
CSTS1:	BIT	7,E		; Taste gedrueckt?
	POP	DE
	RET

;ALLE BENUTZTEN KANAELE SCHLIESSEN, AUSSER COIO
CLCHNL:	PUSH	AF
	PUSH	HL
	PUSH	DE
	PUSH	BC
	LD	DE,0300H+ICH_+CLOSE
	LD	B,6
	LD	A,D
	LD	HL,IOCHNL
CLCHN1:	SRL	(HL)
	CALL	C,IO
CLCHN2:	INC	E
	DJNZ	CLCHN1
	POP	BC
	POP	DE
	POP	HL
	DEFB	3EH
;Setze Tastatur als Eingabekanal
SETCOI:	PUSH	AF
	LD	A,CICH		; Tastatureingabe
	LD	(ININD),A	; IN-Index setzen
	DEFB	3EH
;SETZE Bildschirm als Ausgabekanal
SETCO:	PUSH	AF
	LD	A,COCH		; Bildschirmausgabe
SETCO1:	LD	(OUTIND),A	; OUT-Index setzen
	POP	AF
	RET

;ROUTINE ZUM AKTIVIEREN DER I/O-KANAELE
;AUSGABE
OUTCHL:	LD	A,(HL)
	CP	'#'
	JR	NZ,TCHNL4
	CALL	TCHAR
	JR	NC,TCHNLA
	INC	HL
	PUSH	HL
	AND	3
	JR	Z,TCHNL1
	LD	HL,IOCHNL	; E/A-Flag
	ADD	A,A
	CP	OCH?-1
	JR	Z,TCHNL2
	JR	NC,TCHNL3
	BIT	OM_,(HL)	; Bit 1
	SET	OM_,(HL)	; Bit 1
TCHNO1:	JR	NZ,TCHNL1
TCHNLO:	ADD	A,INIT
TCHNL1:	INC	A
	LD	(OUTIND),A	; OUT-Index
TCHNO2:	POP	HL
TCHNO0:	JP	TCHAR1
TCHNL2:	BIT	OM?,(HL)	; Bit 3
	SET	OM?,(HL)	; Bit 3
	JR	TCHNO1
	;
TCHNL3:	BIT	OM??,(HL)	; Bit 5
	SET	OM??,(HL)	; Bit 5
	JR	TCHNO1
	;
TCHNL4:	PUSH	HL
	XOR	A
	JR	TCHNL1
	
;EINGABE
INCHNL:	LD	A,(HL)
	CP	'#'
	JR	NZ,TCHNL9
	CALL	TCHAR
TCHNLA:	JP	NC,SNER
	INC	HL
	PUSH	HL
	AND	3
	JR	Z,TCHNL6
	LD	HL,IOCHNL	; E/A-Flag
	ADD	A,A
	CP	ICH?
	JR	Z,TCHNL7
	JR	C,TCHNL8
	BIT	IM??,(HL)	; Bit 4
	SET	IM??,(HL)	; Bit 4
TCHNL5:	JR	NZ,TCHNL6
	ADD	A,INIT
TCHNL6:	LD	(ININD),A	; IN-Index
	POP	HL
	JR	TCHNO0
	;
TCHNL7:	BIT	IM?,(HL)	; Bit 2
	SET	IM?,(HL)	; Bit 2
	JR	TCHNL5
	;
TCHNL8:	BIT	IM_,(HL)	; Bit 0
	SET	IM_,(HL)	; Bit 0
	JR	TCHNL5
	;
TCHNL9:	PUSH	HL
	XOR	A
	JR	TCHNL6
 
;ZEILENEDITOR
LINEDI:	PUSH	BC
	CALL	NUMBO1
	POP	HL
	INC	HL
	INC	HL
	INC	HL
	INC	HL
	LD	BC,INPBUF
	PUSH	BC
	JR	EDI2
	;
EDI1:	CALL	WRINPB
EDI2:	LD	A,(HL)
	INC	HL
	CP	'"'
	JR	Z,EDI4
	OR	A
	JR	Z,EDI5
	JP	P,EDI1
	PUSH	BC
	CALL	LIST11		; Token aufloesen
	POP	BC
EDI3:	CALL	WRINPB
	LD	A,(DE)
	INC	DE
	OR	A
	JP	P,EDI3
	JR	EDI2
	;
EDI4:	CALL	WRINPB
	LD	A,(HL)
	INC	HL
	CP	'"'
	JR	Z,EDI1
	OR	A
	JR	NZ,EDI4
EDI5:	LD	A,' '
	INC	BC
	JR	EDI6
	;
WRINPB:	INC	BC
	LD	(BC),A
	PUSH	HL
	LD	HL,-EOINPB+1	; ??? Originalquelltext ohne +1
				; Dann stimmt aber ROM-Code nicht ???
	ADD	HL,BC
	POP	HL
	RET	NC
	POP	HL
	LD	A,'*'
EDI6:	CALL	CO
	XOR	A
	LD	(BC),A
	POP	HL
	LD	(HL),A
	INC	HL
EDI7:	PUSH	HL
	CALL	TEXTOE
	POP	DE
	INC	HL
	LD	(HL),0
	DEC	HL
	LD	(HL),' '
;================================
EDI9:	CALL	CI
	CP	CURDWN		; Cursor nach unten?
	JR	NZ,EDIA
	CALL	ZECR0
	INC	A
	RET
;--------------------------------
EDIA:	CALL	ZECR
	RET	Z
	CALL	ZSTOP
	RET	C
;--------------------------------
	CALL	ZEEDI
	JR	EDI9
;--------------------------------
ZECR:	CP	ASCCR		; CR?
	RET	NZ		; nein
ZECR0:	LD	A,CURRGT	; Cursor nach rechts
	CALL	CO		; ausgeben
	INC	HL
	LD	A,(HL)
	OR	A
	JR	NZ,ZECR0
	DEC	HL
	LD	A,(HL)
	CP	' '
	JR	NZ,ZECR1
	LD	(HL),0
ZECR1:	JP	CRWDY6
;--------------------------------
ZSTOP:	CP	STOPSW		; BRK-Taste?
	JR	Z,ZSTOP1	; ja
	AND	A		; CY=0
	RET
	;
ZSTOP1:	CALL	ZECR0
	SCF			; CY=1
	RET
;--------------------------------
;Eingabe und Editiertasten auswerten:
ZEEDI:	CP	CURLFT		; Cursor nach links?
	JR	Z,ZEDI3
	CP	CURRGT		; Cursor nach rechts?
	JR	Z,ZEDI4
	CP	CURDEL		; DEL?
	JR	Z,ZEDI5
	CP	CURLI		; Shift + Cursor links?
	JP	Z,ZEDI6
	CP	CURRE		; Shift + Cursor rechts?
	JP	Z,ZEDI7
	CP	CLLN		; Shift+DEL?
	JP	Z,ZEDI8
	CP	CURSP		; INS?
	JR	Z,ZEDI9
	CP	CURHIG		; Cursor nach oben?
	RET	Z		; keine Reaktion
	CP	CURDWN		; Cursor nach unten?
	RET	Z		; keine Reaktion
	CP	1		; CLR?
	RET	Z		; keine Reaktion
	CP	ASCSP
	JR	NC,ZEDI42	; ASCII-Zeichen
	CCF		; CY=0
	CALL	CO		; restliche Steuerzeichen ausfuehren
	RET
;--------------------------------
ZEDI42:	LD	(HL),A		; Zeichen in Puffer eintragen
; Cursor nach rechts
ZEDI4:	CALL	CO		; Zeichen anzeigen
	INC	HL		; Puffer + 1
	LD	A,(HL)
	OR	A		; Zeichen auf Puffer-Position?
	RET	NZ
ZEDI41:	LD	DE,EOINPB
	CALL	CPREG
	JR	Z,ZEDI3
	LD	(HL),' '
	INC	HL
	LD	(HL),0
	JR	ZEDI31
;--------------------------------
; Cursor nach links:
ZEDI3:	CALL	CLFTOU	;CURLFT
ZEDI31:	DEC	HL
	LD	A,(HL)
	OR	A
	RET	NZ
ZEDI32:	LD	A,CURRGT
	JR	ZEDI4
;--------------------------------
ZEDI5:	PUSH	HL	;CURDEL
	INC	HL
	CALL	TEXTOE
	CALL	SPOUT
	POP	DE
	XOR	A
ZEDI51:	DEC	HL
	LD	B,(HL)
	LD	(HL),A
	CALL	CLFTOU
	LD	A,B
	JR	NZ,ZEDI51
	RET
;--------------------------------
ZEDI9:	CALL	SPOUT	;CURSP
	PUSH	HL
	CALL	TEXTOE
	LD	DE,EOINPB
	CALL	CPREG
	JR	NZ,ZEDI91
	CALL	CLFTOU
	CALL	SPOUT
	CALL	CLFTOU
	DEC	HL
	LD	(HL),0
ZEDI91:	POP	DE
	LD	B,H
	LD	C,L
	INC	BC
ZEDI92:	LD	A,(HL)
	LD	(BC),A
	DEC	BC
	CALL	CLFTOU
	DEC	HL
	JR	NZ,ZEDI92
	INC	HL
	LD	(HL),' '
	RET
;--------------------------------
ZEDI6:	CALL	CLFTOU	;CURLI
	DEC	HL
	LD	A,(HL)
	OR	A
	JR	NZ,ZEDI6
	JR	ZEDI32
;--------------------------------
ZEDI7:	LD	A,CURRGT	;CURRE
	CALL	CO
	INC	HL
	LD	A,(HL)
	OR	A
	JR	NZ,ZEDI7
	JR	ZEDI41
;--------------------------------
ZEDI8:	CALL	ZEDI6	;CLLN
	PUSH	HL
ZEDI82:	LD	A,(HL)
	OR	A
	JR	Z,ZEDI81
	LD	(HL),' '
	INC	HL
	JR	ZEDI82
	;
ZEDI81:	POP	HL
	CALL	TEXTOE
	CALL	ZEDI6
	INC	HL
	LD	(HL),0
	DEC	HL
	RET
;=================================
;
;Ruecksprung ins uebergeordnete System
MONI:	LD	E,MONIT		; Bit 5=1, d.h. Ruecksprung zu CAOS
IO:	JP	VERT

; 24.01.2021:
; Patch fuer LIST - Ende der Token-Tabelle abfragen

patch:	LD	A,(DE)		; Token-Tabelle lesen
	cp	80h		; Ende der Tabelle
	ret	nz		; nein
	pop	bc		; Stack clear
	xor	a		; nichts tun
	ret			; und Abbruch 

;*************************Programmende*********

ENDX:	
IF	ENDX LT 0E000H
	DS	0E000H-$,0FFH	; Rest mit FF fuellen!
ENDIF
ROMEND:
	.DEPHASE
	END
